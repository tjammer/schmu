-- (def a 'a')

-- (module a
--   (type t int)
--   (module a
--     (type t float)
--     (def a 10)))

-- (print (fmt-str a))

-- -- TODO This module was indeed used
-- (open a)

-- (print (fmt-str a))
-- (print (fmt-str a/a))

(type t {:first& int})
-- (defn print-t [t]
--   (print (fmt-str ":first " t.first)))

-- (defn test []
--   (def x& {:first 10}) -- borrow id 0, own

--   (def y x.first) -- borrow id 1, part 1 of x
--   (print-t x) -- borrow id 2, x
--   (set &x.first 11) -- borrow mut id 3, part 1 of x
--   (ignore y) -- borrow 2 -> conflict!
--   (print-t x))


(defn simple-test []
  (def x& {:first 10}) -- borrow id 0, own

  (def y x) -- borrow id 1, x
  (ignore x) -- borrow id 2, x
  -- (set &x.first 11) -- borrow mut id 3, x
  (ignore y) -- borrow 2 -> conflict!
  (ignore x)

  (def z& x.first)
  (set &z z) -- should be (+ z 1)
  (ignore x)
  (ignore z)

  )
