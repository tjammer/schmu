-- xoshiro256++ https://prng.di.unimi.it/xoshiro256plusplus.c

import libc
import prelude

signature {
  type state

  -- initialize the random state with a specified seed
  val init : fun (int) -> state
  -- self_init() initializes the random state with data from /dev/urandom
  val self_init : fun () -> state
  -- a random value between 0 and 2**64
  val random : fun(mut state) -> int
  -- a random value between 0 and int, exclusive
  val bounded : fun(mut state, int) -> int
  -- a random value between int and int, exclusive
  val bounded2 : fun(mut state, int, int) -> int
}

use prelude

type state = array#4[int]

fun rotl(x, k) {
  lor(lshl(x, k), lshr(x, 64 - k))
}

fun random(mut state : state) {
  let result = rotl(state#[0] + state#[3], 23) + state#[0]
  let t = lshl(state#[1], 17)

  mut state#[2] = lxor(state#[2], state#[0])
  mut state#[3] = lxor(state#[3], state#[1])
  mut state#[1] = lxor(state#[1], state#[2])
  mut state#[0] = lxor(state#[0], state#[3])

  mut state#[2] = lxor(state#[2], t)

  mut state#[3] = rotl(state#[3], 45)

  result
}

fun bounded(mut state, bound : int) {
  -- To avoid bias, we need to make the range of the RNG a multiple of bound,
  -- which we do by dropping output less than a threshold. A naive scheme to
  -- calculate the threshold would be to do
  let threshold = mod(-bound, bound)

  fun rec aux() {
    let r = random(mut state)
    if r >= threshold { mod(r, bound) } else { aux() }
  }

  aux()
}

fun bounded2(mut state, lo, hi) {
  lo + bounded(mut state, hi - lo)
}

fun splitmix64(mut x) {
  mut x = x + 0x9e3779b97f4a7c15
  let mut z = mov x
  mut z = lxor(z, lshr(z, 30)) * 0xbf58476d1ce4e5b9
  mut z = lxor(z, lshr(z, 27)) * 0x94d049bb133111eb
  lxor(z, lshr(z, 31))
}

fun init(seed) {
  let mut state = mov seed
  #[
    splitmix64(mut state),
    splitmix64(mut state),
    splitmix64(mut state),
    splitmix64(mut state)
  ]
}

fun self_init() {
  let filepath = #['/', 'd', 'e', 'v', '/', 'u', 'r', 'a', 'n', 'd', 'o', 'm']
  let fd = libc/open(__fixed_array_data(filepath), 0i32, 0i32)
  let mut seed = #[0]
  mut seed#[0] = 0 -- silence a warning due to unsafe code
  let read = libc/read(fd, __unsafe_ptr_reinterpret(__fixed_array_data(seed)), 8)
  assert(read <> 0) -- TODO use time if this ever fails
  init(seed#[0])
}

main {
  import iter
  import fmt
  import string

  let mut rng = #[1234567, 0, 0, 0]

  iter/range(0, 5) |> iter/iter(fun i {
    fmt/(print1("round {}\n", int, i + 1))
    string/print(" 64 bit:")
    iter_range(0, 6, fun _ {
      fmt/print1(" 0x{}", fun (mov p, i) {
        fmt/int_base_unsigned(p, i, 16)
        }, random(mut rng))
    })
    string/println("\n")
  })
  string/println("splitmix64")
  let mut x = 1234567
  iter/range(0, 5) |> iter/iter(fun _ {
    fmt/println(fmt/uint, splitmix64(mut x))
  })
  string/println("done")
}
