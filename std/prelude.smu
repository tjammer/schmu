(type (ptr 'a) { :ptr (raw_ptr 'a) :length int })

(type (owned_ptr 'a) { :optr& (raw_ptr 'a) :length& int })

-- string
(type cstr (raw_ptr u8))

(type string { :cstr cstr :length int })

(external puts (fun cstr unit))

(fun print [str] (puts (.cstr str)))

(external abs (fun int int))

(fun string-len [str] (abs (.length str)))

-- vector
(type (vector 'a) {:ptr (owned_ptr 'a) :capacity& int})

(fun vector-init [capacity]
  (val optr (__malloc capacity))
  {:ptr {:optr :length 0} :capacity})

(fun vector-get :inline [vec i]
  -- has to be inline until there is proper handling for reference types
  (__unsafe_ptr_get (.optr (.ptr vec)) i))

(fun vector-set [vec i v]
  (__unsafe_ptr_set (.optr (.ptr vec)) i v))

(fun vector-push [vec v]
  (if (= (.length (.ptr vec)) (.capacity vec))
    (do
      (val cap (* (.capacity vec) 2))
      (set (.optr (.ptr vec)) (__realloc (.optr (.ptr vec)) cap))
      (set (.capacity vec) cap)))
  (vector-set vec (.length (.ptr vec)) v)
  (set (.length (.ptr vec)) (+ (.length (.ptr vec)) 1)))

(fun vector-iter [vec f]
  (fun inner [i]
    (if (= i (.length (.ptr vec)))
      ()
      (do
        (f (vector-get vec i))
        (inner (+ i 1)))))
  (inner 0))

(fun vector-fold [vec f init]
  (fun inner [i acc]
    (if (= i (.length (.ptr vec)))
      acc
      (do
        (val acc (f acc (vector-get vec i)))
        (inner (+ i 1) acc))))
  (inner 0 init))

(fun vector-update [vec f]
  (fun inner [i]
    (if (= i (.length (.ptr vec)))
      ()
      (do
        (vector-set vec i (f (vector-get vec i))))))
  (inner 0))

-- option
(type (option 'a) ((#some 'a) #none))

-- ref
(type (ref 'a) {:contents& 'a})

(fun deref :inline [a]
  -- has to be inline until there is proper handling for reference types
  (.contents a))

(fun ref [contents] {:contents})

(fun ref-set [a v] (set (.contents a) v))
