import array
import option
import prelude
import unsafe

module type key {
  type t
  val hash : fun (t) -> int
  val equal : fun (t, t) -> bool
}

module type sig {
  type key
  type t['value]

  val create : fun (int) -> t['value]
  val length : fun (t['value]) -> int
  val insert : fun (t['value]&, key!, 'value!) -> unit
  val remove : fun (t['value]&, key) -> unit

  val find : fun (t['value], key, once fun (option/t['value]) -> 'a) -> 'a
  val find_mut : fun (t['value]&, key, once fun (option/t['value]&) -> 'a) -> 'a
  val mem : fun (t['value], key) -> bool

  val fold : fun (t['value], 'b!, fun ('b!, key, 'value) -> 'c) -> 'c
  val clear : fun (t['value]&) -> unit
  val to_array : fun (t['value]) -> array[(key, 'value)]
}

functor make : sig(m : key) {
  use option
  use prelude

  type key = m/t
  type item['a] = {key : m/t, value& : 'a, pathlen& : int}
  type slot['a] = option/t[item['a]]
  type t['a] = {data& : array[slot['a]], nitems& : int}

  fun create(size) {
    let size = power_2_above(16, size)
    let data& = __unsafe_array_create(size)
    prelude/iter_range(0, size, fun i {
      __unsafe_ptr_set(&array/data(data), i, !None)
    })
    {data, nitems = 0}
  }

  fun length(tbl) { tbl.nitems }

  fun idx(tbl, key) {
    let hash = m/hash(key)
    land(hash, array/length(tbl.data) - 1)
  }

  fun next_wrapped(curr, size) {
    if (curr + 1) == size { 0 } else { curr + 1 }
  }

  fun rec redist(tbl&, item!, curr, pathlen) {
    let size = array/length(tbl.data)
    match tbl.data.[curr] {
      None -> {
        let item& = !item
        &item.pathlen = pathlen
        &tbl.data.[curr] = Some(item)
      }
      Some(other) -> {
        let next = next_wrapped(curr, size)
        if pathlen > other.pathlen {
          let other_pathlen = copy(other.pathlen)
          let new_item = !other
          let item& = !item
          &item.pathlen = pathlen
          &tbl.data.[curr] = Some(item)
          redist(&tbl, !new_item, next, other_pathlen + 1)
        }
        else {
          redist(&tbl, !item, next, pathlen + 1)
        }
      }
    }
  }

  let load_limit = 0.75

  fun load_factor(tbl) {
    float_of_int(tbl.nitems) /. float_of_int(array/length(tbl.data))
  }

  fun iter_data_move(data&, f) {
    fun rec inner(i) {
      if i == array/length(data) {
        &__unsafe_array_length(data) = 0
      }
      else {
        match __unsafe_ptr_get(array/data(data), i) {
          None -> inner(i + 1)
          Some({key, value, pathlen = _}) -> {
            f(!key, !value)
            inner(i + 1)
          }
        }
      }
    }
    inner(0)
  }

  fun rec grow(tbl&) {
    let size = 2 * array/length(tbl.data)
    let data& = __unsafe_array_create(size)
    prelude/iter_range(0, size, fun i {
      __unsafe_ptr_set(&array/data(data), i, !None)
    })
    let old_data& = !tbl.data
    &tbl.data = data
    &tbl.nitems = 0
    iter_data_move(&old_data, fun(key!, value!) {
      insert(&tbl, !key, !value)
    })
  }

  and insert(tbl&, key!, value!) {
    if load_factor(tbl) >. load_limit { grow(&tbl) }
    let hash = idx(tbl, key)
    let size = array/length(tbl.data)

    fun rec insert(i, pathlen, key!, value!) {
      match tbl.data.[i] {
        None -> {
          &tbl.data.[i] = Some({key, value, pathlen})
          &tbl.nitems = tbl.nitems + 1
        }
        Some(other) -> {
          if m/equal(key, other.key) {
            -- overwrite
            &tbl.data.[i] = Some({key, value, pathlen})
          }
          else {
            let next = next_wrapped(i, size)
            if pathlen > other.pathlen {
              let other_pathlen = copy(other.pathlen)
              -- probe sequence length of new value is larger. robin hood
              let other_item = !other
              &tbl.data.[i] = Some({key, value, pathlen})
              &tbl.nitems = tbl.nitems + 1
              redist(&tbl, !other_item, next, other_pathlen + 1)
            }
            else {
              insert(next, pathlen + 1, !key, !value)
            }
          }
        }
      }
    }
    insert(hash, 0, !key, !value)
  }

  fun rec fixup(data&, old) {
    let next = next_wrapped(old, array/length(data))
    match &data.[next] {
      Some(item&) ->
        if not(item.pathlen == 0) {
          &item.pathlen = item.pathlen - 1
          -- swap with old slot, inline
          let oldtmp = !data.[old]
          &data.[old] = data.[next]
          &data.[next] = oldtmp
          fixup(&data, next)
        }
      None -> ()
    }
  }

  fun rec find_index(i, tbl, key, pathlen) {
    match tbl.data.[i] {
      Some(item) ->
        if m/equal(key, item.key) { Some(i) }
        else {
          if pathlen > item.pathlen { None }
          else {
            let next = next_wrapped(i, array/length(tbl.data))
            find_index(next, tbl, key, pathlen + 1)
          }
        }
      None -> None
    }
  }


  fun remove(tbl&, key) {
    let hash = idx(tbl, key)
    match find_index(hash, tbl, key, 0) {
      Some(i) -> {
        &tbl.data.[i] = None
        &tbl.nitems = tbl.nitems - 1
        fixup(&tbl.data, i)
      }
      None -> ()
    }
  }

  fun find(tbl, key, once fn) {
    let hash = idx(tbl, key)
    match find_index(hash, tbl, key, 0) {
      Some(i) -> match tbl.data.[i] {
        Some(item) -> {
          let tmp = unsafe/unchecked(Some(item.value))
          let ret = fn(tmp)
          unsafe/leak(tmp)
          ret
        }
        None -> fn(None)
      }
      None -> fn(None)
    }
  }

  fun find_mut(tbl&, key, once fn) {
    let hash = idx(tbl, key)
    match find_index(hash, tbl, key, 0) {
      Some(i) -> match &tbl.data.[i] {
        Some(item&) -> {
          let tmp& = Some(item.value)
          let ret = fn(&tmp)
          -- our value could have been deleted or changed
          match tmp {
            Some(value) -> &item.value = value
            None -> {
              -- partially copied from [remove]
              &tbl.data.[i] = None
              &tbl.nitems = tbl.nitems - 1
              fixup(&tbl.data, i)
            }
          }
          ret
        }
        None -> {
          let tmp& = None
          let ret = fn(&tmp)
          match tmp {
            None -> ()
            Some(value) -> insert(&tbl, copy(key), value)
          }
          ret
        }
      }
      None -> {
          let tmp& = None
          let ret = fn(&tmp)
          match tmp {
            None -> ()
            Some(value) -> insert(&tbl, copy(key), value)
          }
          ret
        }
    }
  }

  fun mem(tbl, key) {
    let hash = idx(tbl, key)
    match find_index(hash, tbl, key, 0) {
      Some(_) -> true
      None -> false
    }
  }

  fun fold(tbl, init!, f) {
    fun rec inner(i, acc!) {
      if array/length(tbl.data) == i {
        acc
      }
      else {
        match tbl.data.[i] {
          None -> inner(i + 1, !acc)
          Some({key, value, pathlen = _}) ->
          inner(i + 1, !f(!acc, key, value))
        }
      }
    }
    inner(0, !init)
  }

  fun clear(tbl&) {
    array/clear(&tbl.data)
    &tbl.nitems = 0
  }

  fun iter_data(data, f) {
    fun rec inner(i) {
      if array/length(data) == i { () }
      else {
        match data.[i] {
          None -> inner(i + 1)
          Some({key, value, pathlen = _}) -> {
            f(key, value)
            inner(i + 1)
          }
        }
      }
    }
    inner(0)
  }

  fun to_array(tbl) {
    let arr& = array/create(tbl.nitems)
    iter_data(tbl.data, fun(key, value) {
      array/push(&arr, !(copy(key), copy(value)))
    })
    arr
  }

}
