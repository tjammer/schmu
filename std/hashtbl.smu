(module-type key
  (type t)
  (def hash (fun t int))
  (def equal (fun t t bool)))

(module-type sig
  (type key)
  (type (t 'value))

  (def create (fun int (t 'value)))
  (def insert (fun (t 'value)& key! 'value! unit))
  (def remove (fun (t 'value)& key unit))
  (def find (fun (t 'value) key (option/t 'value)))
  (def fold (fun (t 'value) 'c! (fun 'c! key 'value 'c) 'c))
  (def to-array (fun (t 'value) (array {key 'value})))

  (def print-impl (fun (t 'value) unit)))

(functor [make sig] ([m key])
  (import option)

  (type key m/t)
  (type (item 'a) {:key m/t :value 'a :pathlen& int})
  (type (slot 'a) (option/t (item 'a)))
  (type (t 'a) {:data& (array (slot 'a)) :nitems& int})

  (defn power-2-above (x n)
    (if (>= x n)
      x
      (if (< (* x 2) 0)
        x
        (power-2-above (* x 2) n))))

  (defn create (size)
    (def size (power-2-above 16 size))
    (def data& (__unsafe_array_create size))
    (prelude/iter-range 0 size
                        (fn (i) (__unsafe_ptr_set &(array/data data) i !#none)))
    {:data :nitems 0})

  (defn idx (tbl key)
    (let ((hash (m/hash key)))
      (land hash (- (array/length tbl.data) 1))))

  (defn next-wrapped (curr size)
    (if (= (+ curr 1) size) 0 (+ curr 1)))

  (defn redist (tbl& item! curr pathlen)
    (def size (array/length tbl.data))
    (match tbl.data.[curr]
      (#none (let ((item& !item))
               (set &item.pathlen !pathlen)
               (set &tbl.data.[curr] !(#some item))))
      ((#some other)
       (let ((next (next-wrapped curr size)))
         (if (> pathlen other.pathlen)
           (let ((new-item !other)
                 (other-pathlen (copy other.pathlen))
                 (item& !item))
             (set &item.pathlen !pathlen)
             (set &tbl.data.[curr] !(#some item))
             (redist &tbl !new-item next (+ other-pathlen 1)))
           (redist &tbl !item next (+ pathlen 1)))))))

  (def load-limit 0.75)

  (defn load-factor (tbl)
    (/. (float_of_int tbl.nitems) (float_of_int (array/length tbl.data))))

  (defn iter-data-move (data& f)
    (defn inner (i)
      (if (= i (array/length data))
        (set &(__unsafe_array_length data) !0)
        (match (__unsafe_ptr_get (array/data data) i)
          (#none (inner (+ i 1)))
          ((#some {:key :value :pathlen _})
           (do
             (f !key !value)
             (inner (+ i 1)))))))
    (inner 0))

  (rec
   (defn grow (tbl&)
     (def size (* 2 (array/length tbl.data)))
     (def data& (__unsafe_array_create size))
     (prelude/iter-range 0 size
                         (fn (i) (__unsafe_ptr_set &(array/data data) i !#none)))
     (def old-data& !tbl.data)
     (set &tbl.data !data)
     (set &tbl.nitems !0)
     (iter-data-move &old-data (fn (key! value!) (insert &tbl !key !value))))

   (defn insert (tbl& key! value!)
     (if (>. (load-factor tbl) load-limit)
       (grow &tbl))
     (def hash (idx tbl key))
     (def size (array/length tbl.data))

     (defn insert (i pathlen key! value!)
       (match tbl.data.[i]
         (#none
          (do (set &tbl.data.[i]
                   !(#some {:key :value :pathlen}))
              (set &tbl.nitems !(+ 1 tbl.nitems))))
         ((#some other)
          (if (m/equal key other.key)
            -- overwrite
            (set &tbl.data.[i] !(#some {:key :value :pathlen}))
            (let ((next (next-wrapped i size)))
              (if (> pathlen other.pathlen)
                (let ((other-pathlen (copy other.pathlen))
                      -- probe sequence length of new value is larger. robin hood
                      (other-item !other))
                  (set &tbl.data.[i] !(#some {:key :value :pathlen}))
                  (set &tbl.nitems !(+ 1 tbl.nitems))
                  (redist &tbl !other-item next (+ other-pathlen 1)))
                (insert next (+ pathlen 1) !key !value)))))))

     (insert hash 0 !key !value)))

  (defn find-index (i tbl key pathlen)
    (match tbl.data.[i]
      ((#some item)
       (if (m/equal key item.key)
         (#some i)
         (if (> pathlen item.pathlen)
           #none
           (let ((next (next-wrapped i (array/length tbl.data))))
            (find-index next tbl key (+ pathlen 1))))))
      (#none #none)))

  (defn find (tbl key)
    (def hash (idx tbl key))
    (match (find-index hash tbl key 0)
      ((#some i) (match tbl.data.[i]
                  ((#some item) (#some (copy item.value)))
                  (#none #none)))
      (#none #none)))

  (defn fixup (data& old)
    (def next (next-wrapped old (array/length data)))
    (match &data.[next]
      ((#some item&)
       (if (not (= item.pathlen 0))
         (do (set &item.pathlen !(- item.pathlen 1))
             -- swap with old slot, inline
             (let ((oldtmp !data.[old]))
               (set &data.[old] !data.[next])
               (set &data.[next] !oldtmp))
             (fixup &data next))))
      (#none ())))

  (defn remove (tbl& key)
    (def hash (idx tbl key))
    (match (find-index hash tbl key 0)
      ((#some i)
       (do (set &tbl.data.[i] !#none)
           (set &tbl.nitems !(- tbl.nitems 1))
           (fixup &tbl.data i)))
      (#none ())))

  (defn fold (tbl init! f)
    (defn inner (i acc!)
      (if (= i (array/length tbl.data))
        acc
        (match tbl.data.[i]
          (#none (inner (+ i 1) !acc))
          ((#some {:key :value :pathlen _})
           (inner (+ i 1) !(f !acc key value))))))
    (inner 0 !init))

  (defn iter-data (data f)
    (defn inner (i)
      (if (= i (array/length data))
        ()
        (match data.[i]
          (#none (inner (+ i 1)))
          ((#some {:key :value :pathlen _})
           (do
             (f key value)
             (inner (+ i 1)))))))
    (inner 0))

  (defn to-array (tbl)
    (let ((arr& (array/create tbl.nitems)))
      (iter-data tbl.data
                 (fn (key value) (array/push &arr !{(copy key) (copy value)})))
      arr))

  (defn print-impl (tbl)
    (defn string-of-slot (slot)
      (match slot
        ((#some item) (fmt-str "(some " item.value " " item.pathlen ")"))
        (#none "none")))
    (let ((lst (string/concat " " (array/map tbl.data string-of-slot))))
      (string/print (fmt-str "[" lst "]")))))
