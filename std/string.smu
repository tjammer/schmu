import array
import iter
import libc
import option
import prelude

signature {
  type cstr = raw_ptr[u8]
  type t

  val len : fun (t) -> int
  val data : fun (t) -> cstr
  val get : fun (t, int) -> u8
  val hash : fun (t) -> int
  val equal: fun (t, t) -> bool
  val compare : fun (t, t) -> int
  val append : fun (mut t, t) -> unit
  val concat : fun (t, array[t]) -> t
  -- substr(str, start, end)
  val substr : fun (t, int, int) -> t
  -- find(str, start, pattern) returns an option to the index where the pattern
  -- was first found in str from start
  val find : fun (t, int, t) -> option/t[int]
  -- end_with(str, pattern) return true if str ends with pattern
  val ends_with : fun (t, t) -> bool
  -- cut(str, start, pattern) iterates over str slices from index separated
  -- by pattern
  val cut : fun (t, int, t, iter/consumer[t]) -> iter/continue

  val modify_buf : fun (mut t, once fun (mut array[u8]) -> unit) -> unit
  val of_array : fun (mov array[u8]) -> t
  val to_array : fun (mov t) -> array[u8]
  val of_fixed_array : fun (array#?[u8]) -> t
  val of_cstr : fun (cstr) -> t

  val println : fun (t) -> unit
  val print : fun (t) -> unit
  val prerrln : fun (t) -> unit
  val prerr : fun (t) -> unit
}

type t = array[u8]

-- TODO use aliases
fun len(str : t) { array/length(str) }
fun data(str : t) { array/data(str) }
fun get(str : t, i) { str.[i] }

use prelude
use libc

fun hash(str) {
  -- unsigned long
  -- hash(unsigned char *str)
  -- {
  --     unsigned long hash = 5381;
  --     int c;
  --     while (c = *str++)
  --         hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
  --     return hash;
  -- }
  use iter
  array/iter(str) |> fold(mov 5381, fun (mov hash, c) {
    (hash * 33) + int_of_u8(c)
  })
}

fun equal(l, r) {
  if len(l) == len(r) {
    int_of_i32(memcmp(array/data(l), array/data(r), array/length(l))) == 0
  } else {
    false
  }
}

fun compare(l, r) {
  if len(l) == len(r) {
    memcmp(array/data(l), array/data(r), array/length(r))
    |> int_of_i32
  }
  else {
    len(l) - len(r)
  }
}

fun append(mut str, other) {
  use iter
  array/iter(other) |> iter(fun(c : u8) { array/push(mut str, mov c) })
}

fun concat(delim, strings) {
  let mut ret = array/create(32)
  array/iter(strings) |> iter/iteri(fun(i, str) {
    if not(i == 0) { append(mut ret, delim) }
    append(mut ret, str)
  })
  array/push(mut ret, mov '\000')
  array/pop_back(mut ret) |> ignore
  ret
}

fun substr(str : t, start, end) {
  assert(start >= 0)
  assert(end <= len(str))

  let size = end - start
  assert(size >= 0)

  let mut arr = array/create(size + 1)
  memcpy(array/data(arr), __unsafe_ptr_at(data(str), start), size)
  mut arr.[size] = '\000'
  mut __unsafe_array_length(arr) = size
  arr
}

fun make_skips(pattern) {
  let len = array/length(pattern)
  let mut skips = #256[len]
  array/iter(pattern) |> iter/iteri(fun(i, c) {
    if not(i == len - 1) {
      -- ignore last char
      mut skips#[int_of_u8(c)] = len - 1 - i
    }
  })
  skips
}

fun boyer_moore_horspool(str, start, pattern) {
  use prelude
  use option
  let patlen1 = len(pattern) - 1
  let strptr = array/data(str)
  let last_patchar = pattern.[patlen1]

  fun rec find(skips, istr) {
    let last_windowchar = str.[istr + patlen1]
    if (istr + len(pattern)) <= len(str) {
      if char_equal(last_patchar, last_windowchar)
      and (memcmp(array/data(pattern),
                  __unsafe_ptr_at(strptr, istr), patlen1)
           |> int_of_i32) == 0 {
        Some(istr)
      } else {
        let skip = skips#[int_of_u8(last_windowchar)]
        find(skips, istr + skip)
      }
    } else { None }
  }

  -- what's going on here?
  if len(pattern) < len(pattern) {
    None
  } else {
    let skips = make_skips(pattern)
    find(skips, start)
  }
}

let find = boyer_moore_horspool

fun cut(str, start, pat, cont) {
  fun rec inner(mov tmp, start) {
    let mut tmp = mov tmp
    fun fixup_tmp(index) {
      let size = index - start + len(pat)
      array/reserve(mut tmp, size + 1) -- null terminator
      libc/memcpy(data(tmp), __unsafe_ptr_at(data(str), start), size)
      -- fix null terminator
      __unsafe_ptr_set(mut array/data(tmp), size, '\000')
      -- fix length
      mut __unsafe_array_length(tmp) = index - start
    }
    match find(str, start, pat) {
      None -> {
        -- return the rest of the string
        let len = array/length(str)
        if len - start > 1 {
          fixup_tmp(len)
          if not(array/empty(tmp)) { cont(tmp) |> ignore }
          false
        }
        else { false }
      }
      Some(index) -> {
        fixup_tmp(index)
        if array/empty(tmp) or cont(tmp) { inner(tmp, index + len(pat)) }
        else { false }
      }
    }
  }
  inner([], start)
}

fun ends_with(str, pat) {
  fun rec aux(istr, ipat) {
    if ipat < 0 { true }
    else if istr < 0 { false }
    else {
      if char_equal(get(str, istr), get(pat, ipat)) {
        aux(istr -1, ipat -1)
      }
      else { false }
    }
  }
  aux(len(str) - 1, len(pat) - 1)
}

fun modify_buf(mut str : t, f) {
  f(mut str)
  -- return type needs to be inferred as unit
  ()
}

fun of_array(mov arr : array[u8]) {
  -- always add null terminator. The array might have a hidden null terminator
  -- already, but we can't be certain and don't want each caller to remember
  -- adding null.
  let mut arr = mov arr
  array/push(mut arr, '\000')
  array/pop_back(mut arr) |> ignore
  arr
}

fun to_array(mov str : t) { str }

fun of_fixed_array(arr : array#?[u8]) {
  let ret = array/create(__fixed_array_length(arr))
  memcpy(array/data(ret), __fixed_array_data(arr), __fixed_array_length(arr))
  ret
}

fun of_cstr(cstr) {
  -- NOTE we could implement this without traversing the string twice
  let size = strlen(cstr)
  let mut arr = array/create(size + 1)
  -- copy null terminator
  memcpy(array/data(arr), cstr, size + 1)
  mut __unsafe_array_length(arr) = size
  arr
}

let newline = #['\n']

fun println(str : t) {
  fwrite(array/data(str), 1, array/length(str), libc/stdout)
  fwrite(__fixed_array_data(newline), 1, 1, libc/stdout)
}

fun print(str : t) {
  fwrite(array/data(str), 1, array/length(str), libc/stdout)
}

fun prerrln(str : t) {
  fwrite(array/data(str), 1, array/length(str), libc/stderr)
  fwrite(__fixed_array_data(newline), 1, 1, libc/stderr)
}

fun prerr(str : t) {
  fwrite(array/data(str), 1, array/length(str), libc/stderr)
}
