signature:
  type cstr = raw_ptr(u8)
  type t

  val len : (t) -> int
  val data : (t) -> cstr
  val get : (t, int) -> u8
  val hash : (t) -> int
  val equal: (t, t) -> bool
  val append : (t&, t) -> unit
  val concat : (t, array(t)) -> t
  val boyer_moore_horspool : (t, t) -> Option.t(int)

  val modify_buf : (t&, (array(u8)&) -> unit) -> unit
  val of_array : (array(u8)!) -> t
  val to_array : (t!) -> array(u8)
  val of_fixed_array : (array#?(u8)) -> t

  val print : (t) -> unit

type t = array(u8)

-- TODO use aliases
fun len(str : t): Array.length(str)
fun data(str : t): Array.data(str)
fun get(str : t, i): str.[i]

fun hash(str):
  -- unsigned long
  -- hash(unsigned char *str)
  -- {
  --     unsigned long hash = 5381;
  --     int c;
  --     while (c = *str++)
  --         hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
  --     return hash;
  -- }
  Array.fold(str, !5381, fun (hash!, c):
    (hash * 33) + u8_to_int(c))

external memcmp : (raw_ptr(u8), raw_ptr(u8), int) -> i32

fun equal(l, r):
  if len(l) == len(r):
    int_of_i32(memcmp(Array.data(l), Array.data(r), Array.length(l))) == 0
  else:
    false

fun append(str&, other):
  Array.iter(other, fun(c : u8): Array.push(&str, !c))

fun concat(delim, strings):
  let ret& = Array.create(32)
  Array.iteri(strings, fun(i, str):
    if not(i == 0): append(&ret, delim)
    append(&ret, str))
  Array.push(&ret, !'\000')
  Array.drop_back(&ret)
  ret

fun make_skips(pattern):
  let len = Array.length(pattern)
  let skips& = #256[len]
  Array.iteri(pattern, fun(i, c):
    if not(i == len - 1): -- ignore last char
      &skips#[u8_to_int(c)] <- len - 1 - i)
  skips

fun boyer_moore_horspool(pattern, str):
  import Prelude
  import Option
  let patlen1 = len(pattern) - 1
  let strptr = Array.data(str)
  let last_patchar = pattern.[patlen1]

  fun find(skips, istr):
    let last_windowchar = str.[istr + patlen1]
    if (istr + len(pattern)) <= len(str):
      if char_equal(last_patchar, last_windowchar) and
        (memcmp(Array.data(pattern), __unsafe_ptr_at(strptr, istr), patlen1)
          -> int_of_i32) == 0:
        Some(istr)
      else:
        let skip = skips#[u8_to_int(last_windowchar)]
        find(skips, istr + skip)
    else:
      None

  -- what's going on here?
  if len(pattern) < len(pattern): None else:
    let skips = make_skips(pattern)
    find(skips, 0)

fun modify_buf(str& : t, f):
  f(&str)
  -- return type needs to be inferred as unit
  ()

fun of_array(arr! : array(u8)): arr
fun to_array(str! : t): str

external memcpy : (raw_ptr(u8), raw_ptr(u8), int) -> unit

fun of_fixed_array(arr : array#?(u8)):
  let ret = Array.create(__fixed_array_length(arr))
  memcpy(Array.data(ret), __fixed_array_data(arr), __fixed_array_length(arr))
  ret

type file = raw_ptr(u8)
external stdout : file
external fwrite : (cstr, int, int, file) -> unit

let newline = #['\n']

fun print(str : t):
  -- TODO should be named println, but (print (fmt-str ...)) also adds newline
  fwrite(Array.data(str), 1, Array.length(str), stdout)
  fwrite(__fixed_array_data(newline), 1, 1, stdout)
