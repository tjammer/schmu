import prelude

signature {
  type continue = bool
  type t['a] = (('a) -> continue) -> continue
  type consumer['a] = ('a) -> continue

  -- creators
  val range : (int, int, consumer[int]) -> continue

  -- manipulators
  val map : (t['a], ('a) -> 'b, consumer['b]) -> continue
  val filter : (t['a], ('a) -> bool, consumer['a]) -> continue
  val take : (t['a], int, consumer['b]) -> continue

  -- consumers
  val iter : (t['a], ('a) -> unit) -> unit
  val iteri : (t['a], (int, 'a) -> unit) -> unit
  val fold : (t['a], 'b!, ('b!, 'a) -> 'b) -> 'b
  val foldi : (t['a], 'b!, (int, 'b!, 'a) -> 'b) -> 'b
}

use prelude

-- iter creators
fun range(from, to, cont) {
  fun rec inner(i) {
    if i == to { false }
    else {
      if cont(i) { inner(i + 1) }
      else { false }
    }
  }
  inner(from)
}

-- iter manipulators
fun map(it : t['a], f, cont : consumer['b]){
  it(fun x { cont(f(x)) })
}

fun filter(it : t['a], f, cont){
  it(fun x {
    if f(x) { cont(x) }
    else { true }
  })
}

fun take(it : t['a], stop, cont) {
  let curr& = 0
  it(fun x {
    if curr == stop { false }
    else {
      if cont(x) {
        &curr = curr + 1
        true
      }
      else { false }
    }
  })
}

-- iter consumers
fun fold(it : t['a], init!, f) {
  let r& = !init
  it(fun x {
    &r = f(!r, x)
    true
  }) |> ignore
  r
}

fun foldi(it : t['a], init!, f) {
  let r& = !init
  let i& = 0
  it(fun x {
    &r = f(i, !r, x)
    &i = i + 1
    true
  }) |> ignore
  r
}

fun iter(it : t['a], f) {
  it(fun x {
    f(x)
    true
  }) |> ignore
}

fun iteri(it : t['a], f) {
  let i& = 0
  it(fun x {
    f(i, x)
    &i = i + 1
    true
  }) |> ignore
}
