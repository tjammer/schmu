signature:
  type t

  val open : (String.t) -> Option.t(t)
  val close : (t) -> unit

  -- high level interface
  val with_open : (String.t, (t&) -> 'a) -> Option.t('a)
  val readall : (t&) -> String.t
  val lines : (t&, (String.t) -> unit) -> unit

  -- low level interface
  type buf = array(u8)
  val readbuf : (t&, buf&) -> Option.t(int)
  val readn : (t&, buf&, int) -> Option.t(int)
  val readline : (t&, buf&) -> Option.t(int)
  val readrem : (t&, buf&) -> Option.t(int)

type file = raw_ptr(u8)

type t = {buf& : array#4096(u8), head& : int, unseen& : int, file : file}

type cstr = raw_ptr(u8)
external fread : (cstr, int, int, file) -> int
external fopen : (cstr, cstr) -> file
external fclose : (cstr) -> int

import Option

let bufsize = 4096

fun open(name):
  let file = fopen(String.data(name), String.data("r"))
  if nullptr?(file): None else:
    Some({buf = #4096[0u8], head = 0, unseen = 0, file})

fun close(ic):
  fclose(ic.file) -> ignore

fun with_open(name, f):
  match open(name):
    Some(ic):
      let ic& = !ic
      let ret = f(&ic)
      close(ic)
      Some(ret)
    None: None

fun fill(buf&, icbuf, lower, upper):
  Prelude.iter_range(lower, upper, fun i:
    Array.push(&buf, !copy(icbuf#[i])))

fun readbuf(ic&, buf&):
  let lower, upper = do:
    if ic.unseen > 0:
      (ic.head, ic.head + ic.unseen)
    else:
      (0, fread(__fixed_array_data(ic.buf), 1, bufsize, ic.file))
  -- copy content to buf
  fill(&buf, ic.buf, lower, upper)
  &ic.head <- 0
  &ic.unseen <- 0
  Some(upper - lower)

fun readn_impl(ic&, buf&, n, readacc):
  if ic.unseen >= n:
    fill(&buf, ic.buf, ic.head, ic.head + n)
    &ic.head <- ic.head + n
    &ic.unseen <- ic.unseen - n
    Some(readacc + n)
  else if ic.unseen > 0:
    match readbuf(&ic, &buf):
      Some(nread):
        assert((n - nread) < 0)
        readn_impl(&ic, &buf, n - nread, nread + readacc)
      None:
        assert(false)
        None
  else:
    let nread = fread(__fixed_array_data(ic.buf), 1, bufsize, ic.file)
    &ic.head <- 0
    &ic.unseen <- copy(nread)
    if nread == 0:
      if readacc == 0: None else: Some(readacc)
    else:
      readn_impl(&ic, &buf, n, readacc)


fun readn(ic&, buf&, n): readn_impl(&ic, &buf, n, 0)

fun readall_impl(ic&, buf&, acc):
  -- assumes ic.unseen = 0
  let nread = fread(__fixed_array_data(ic.buf), 1, bufsize, ic.file)
  if nread == 0:
    if acc == 0: None else: Some(acc)
  else:
    fill(&buf, ic.buf, 0, nread)
    readall_impl(&ic, &buf, nread + acc)

fun readrem(ic&, buf&):
  let ret = match readbuf(&ic, &buf):
    Some(nread):
      fill(&buf, ic.buf, ic.head, ic.head + ic.unseen)
      readall_impl(&ic, &buf, nread)
    None: None
  -- make other (read) calls fail after this
  &ic.unseen <- 0
  &ic.head <- 0
  ret

fun readline(ic&, buf&):
  fun find_newline(acc):
    if ic.unseen > 0:
      if Prelude.char_equal('\n', ic.buf#[ic.head]):
        &ic.unseen <- ic.unseen - 1
        &ic.head <- ic.head + 1
        Some(acc)
      else:
        Array.push(&buf, !copy(ic.buf#[ic.head]))
        &ic.unseen <- ic.unseen - 1
        &ic.head <- ic.head + 1
        find_newline(acc + 1)
    else:
      -- re-read file, then recurse, copied from readn_impl
      let nread = fread(__fixed_array_data(ic.buf), 1, bufsize, ic.file)
      &ic.head <- 0
      &ic.unseen <- copy(nread)
      if nread == 0:
        if acc == 0: None else: Some(acc)
      else: find_newline(acc)
  find_newline(0)

fun readall(ic&):
  let buf& = Array.create(bufsize)
  match readrem(&ic, &buf):
    Some(_): String.of_array(!buf)
    None: ""

fun lines(ic&, f):
  let buf& = Array.create(bufsize)
  fun aux():
    match readline(&ic, &buf):
      Some(_):
        let str = String.of_array(!buf)
        f(str)
        &buf <- String.to_array(!str)
        Array.clear(&buf)
        aux()
      None: ()
  aux()
