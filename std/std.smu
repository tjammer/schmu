import array
import deque
import float
import fmt
import hashtbl
import in_channel
import int
import iter
import libc
import option
import prelude
import random
import rc
import set
import string
import sys
import unsafe

type string = string/t

let println = string/println
let print = string/print
let cstr = string/data

type option['a] = option/t['a]
type result['a, 'e] = Ok('a) | Err('e)

-- prelude re-exports
let char_equal = prelude/char_equal
let iter_range = prelude/iter_range

module array = array
module deque = deque
module float = float
module fmt = fmt
module hashtbl = hashtbl
module in_channel = in_channel
module int = int
module iter = iter
module libc = libc
module option = option
module random = random
module rc = rc
module set = set
module string = string
module sys = sys
module unsafe = unsafe

fun failwith(msg) {
  string/prerr("failwith: ")
  string/prerrln(msg)
  __any_abort()
}

fun exit(msg, status) {
  string/prerrln(msg)
  __any_exit(i32_of_int(status))
}

-- common operators
let + = int/(+)
let - = int/(-)
let * = int/(*)
let / = int/(/)

let < = int/(<)
let > = int/(>)
let <= = int/(<=)
let >= = int/(>=)
let == = int/(==)
let <> = int/(<>)

let +. = float/(+)
let -. = float/(-)
let *. = float/(*)
let /. = float/(/)

let <. = float/(<)
let >. = float/(>)
let <=. = float/(<=)
let >=. = float/(>=)
let ==. = float/(==)
let <>. = float/(<>)

fun read_int() {
  -- will be re-allocated automatically if it's too small
  let mut buf = array/init(256, '\000')
  let mut len = array/length(buf)
  let read = libc/getline(mut array/data(buf), mut len, libc/stdin)

  if read == -1 { None }
  else {
    let mut ptr = array/data(buf)
    let result = libc/strtol(array/data(buf), mut ptr, 0)
    -- we expect a newline, otherwise it failed
    if char_equal(unsafe/get(ptr, 0), '\n') { Some(result) }
    else { None }
  }
}
