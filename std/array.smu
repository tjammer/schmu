import iter
import option
import prelude
import random

-- TODO write signature

-- signature {
--   type t['a] = array['a]

--   -- create(len) returns an empty array of capacity len
--   val create : fun (int) -> t['a]
--   -- init(len, mov value) returns an array of length len with copies of value
--   val init : fun (int, mov 'a) -> t['a]
--   -- push(mut arr, mov value) appends value to arr
--   val push : fun (mut t['a], mov 'a) -> unit
--   -- length(arr) returns the length of arr
--   val length : fun (t['a]) -> int
--   -- iter(arr, cont) is the iterator of arr
--   val iter : fun (t['a], iter/consumer['a]) -> iter/continue
--   -- data(arr) returns a raw ptr to arr's data
--   val data : fun (t['a]) -> raw_ptr['a]
--   -- empty(arr) returns if the value is empty
--   val empty : fun (t['a]) -> bool
--   -- map(arr, f) returns a new array with values f(items of arr)
--   val map : fun (t['a], fun ('a) -> 'b) -> t['b]
--   -- map_inplace(mut arr, f) applies f(items of arr)
--   val map_inplace : fun (mut t['a], fun (mut 'a) -> unit) -> unit
--   -- clear(mut arr) removes all entries of arr
--   val clear : fun (mut t['a]) -> unit
--   -- pop_back(mut arr) returns the last element
--   val pop_back : fun (mut t['a]) -> option/t['a]
--   -- reserve(mut arr, len) ensures arr's capacity is at least len
--   val reserve : fun (mut t['a], int) -> unit
--   -- reverse(mut arr) reverses the order of items in arr
--   val reverse : fun (mut t['a]) -> unit
--   -- swap_items(mut arr, i, j) swaps items at i and j in place
--   val swap_items : fun (mut t['a], int, int) -> unit
--   -- shuffle(mut rs, mut arr) shuffles the order of items in arr in place
--   val shuffle : fun (mut random/state, mut t['a]) -> unit
-- }

let data = __array_data
let length = __array_length

use prelude

fun create(len) {
  let mut arr = __unsafe_array_create()
  mut __unsafe_array_length(arr) = 0
  if len > 0 {
    mut data(arr) = __unsafe_malloc(len)
    mut __unsafe_array_capacity(arr) = len
  }
  else {
    mut data(arr) = __unsafe_ptr_reinterpret(__unsafe_nullptr())
    mut __unsafe_array_capacity(arr) = 0
  }
  arr
}

fun init(len, mov value) {
  let mut arr = __unsafe_array_create()
  mut __unsafe_array_length(arr) = len
  if len > 0 {
    mut data(arr) = __unsafe_malloc(len)
    mut __unsafe_array_capacity(arr) = len
  }
  else {
    mut data(arr) = __unsafe_ptr_reinterpret(__unsafe_nullptr())
    mut __unsafe_array_capacity(arr) = 0
  }
  fun rec inner(i) {
    if i == len { () }
    else {
      -- a normal mutation would free an uninitialized value
      __unsafe_ptr_set(mut data(arr), i, copy(value))
      inner(i + 1)
    }
  }
  inner(0)
  arr
}

fun push(mut arr, mov value) {
  let capacity = __array_capacity(arr)
  let length = length(arr)

  if capacity == length {
    if capacity == 0 {
      assert(is_nullptr(data(arr)))
      mut data(arr) = __unsafe_malloc(4)
      mut __unsafe_array_capacity(arr) = 4
    } else {
      assert(is_nullptr(data(arr)) |> not)
      let cap = power_2_above_or_equal(capacity, capacity + 1)
      mut data(arr) = __unsafe_realloc(data(arr), cap)
      mut __unsafe_array_capacity(arr) = cap
    }
  }

  __unsafe_ptr_set(mut data(arr), length, mov value)
  mut __unsafe_array_length(arr) = length + 1
}

fun iter(arr, cont) {
  fun rec inner(i) {
    if i == length(arr) { false }
    else {
      if cont(arr.[i]) { inner(i + 1) }
      else { false }
    }
  }
  inner(0)
}

fun riter(arr, cont) {
  fun rec inner(i) {
    if i < 0 { false }
    else {
      if cont(arr.[i]) { inner(i - 1) }
      else { false }
    }
  }
  inner(length(arr) - 1)
}

fun collect(it) {
  let mut arr = create(4)
  let _ : bool = it(fun x {
    push(mut arr, copy(x))
    true
  })
  arr
}

fun map(arr, f) {
  let ret = create(length(arr))
  fun rec inner(mov ret, i) {
    let mut ret = mov ret
    if i == length(arr) {
      ret
    } else {
      push(mut ret, mov f(arr.[i]))
      inner(mov ret, i + 1)
    }
  }

  inner(mov ret, 0)
}

fun map_inplace(mut arr, f) {
  fun rec inner(i) {
    if i == length(arr) {
      ()
    } else {
      f(mut arr.[i])
      inner(i + 1)
    }
  }

  inner(0)
}

fun pop_back(mut arr) {
  use option
  if length(arr) == 0 {
    None
  }
  else {
    Some(__unsafe_array_pop_back(mut arr))
  }
}

fun swap_items(mut arr, i, j) {
  if not (i == j) {
    let itmp = mov arr.[i]
    mut arr.[i] = arr.[j]
    mut arr.[j] = itmp
  }
}

fun clear(mut arr) {
  fun rec inner() {
    if 0 == length(arr) {
      ()
    } else {
      pop_back(mut arr) |> ignore
      inner()
    }
  }

  inner()
}

fun reserve(mut arr, size) {
  let cap = __array_capacity(arr)
  let startcap = if cap > 0 { cap } else { 1 }
  if cap < size {
    let newcap = power_2_above_or_equal(startcap, size)
    if is_nullptr(data(arr)) {
      mut data(arr) = __unsafe_malloc(newcap)
    }
    else {
      mut data(arr) = __unsafe_realloc(data(arr), newcap)
    }
    mut __unsafe_array_capacity(arr) = newcap
  }
}

fun reverse(mut arr) {
  let length = length(arr)
  iter_range(0, length / 2, fun i {
    swap_items(mut arr, i, length - i - 1)
  })
}

-- https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
fun shuffle(mut rs, mut arr) {
  let len = length(arr)
  iter/range(0, len - 1) |> iter/iter(fun i {
    let j = random/bounded2(mut rs, i, len)
    swap_items(mut arr, i, j)
  })
}

fun empty(arr) { length(arr) == 0 }

fun initf(len, f) {
  let mut arr = __unsafe_array_create()
  mut __unsafe_array_length(arr) = len
  if len > 0 {
    mut data(arr) = __unsafe_malloc(len)
    mut __unsafe_array_capacity(arr) = len
  }
  else {
    mut data(arr) = __unsafe_ptr_reinterpret(__unsafe_nullptr())
    mut __unsafe_array_capacity(arr) = 0
  }
  fun rec inner(i) {
    if i == len { () }
    else {
      -- a normal mutation would free an uninitialized value
      __unsafe_ptr_set(mut data(arr), i, f(i))
      inner(i + 1)
    }
  }
  inner(0)
  arr
}

fun merge(mut arr, mut tmp, startl, endl, startr, endr, cmp) {
  fun rec fill(i, curl, curr) {
    let endl = curl > endl
    let endr = curr > endr
    if endl and endr { () }
    else if endl {
      mut tmp.[i] = curr
      fill(i + 1, curl, curr + 1)
    }
    else if endr {
      mut tmp.[i] = curl
      fill(i + 1, curl + 1, curr)
    }
    else {
      if cmp(arr.[curl], arr.[curr]) < 0 {
        mut tmp.[i] = curl
        fill(i + 1, curl + 1, curr)
      }
      else {
        mut tmp.[i] = curr
        fill(i + 1, curl, curr + 1)
      }
    }
  }
  fill(startl, startl, startr)

  fun rec find_index(mut index, i) {
    if index < i {
      mut index = tmp.[index]
      find_index(mut index, i)
    }
    else { () }
  }

  fun rec cpy(i) {
    if i > endr { () }
    else {
      let mut index = mov tmp.[i]
      -- this index has been swapped to a higher position
      find_index(mut index, i)
      swap_items(mut arr, i, index)
      -- remember that item i now lives at index
      mut tmp.[i] = index
      cpy(i + 1)
    }
  }
  cpy(startl)
}

fun rec merge_sort(mut arr, mut tmp, i, n, cmp) {
  if n < 2 { () }
  else {
    let m = n / 2
    merge_sort(mut arr, mut tmp, i, m, cmp)
    merge_sort(mut arr, mut tmp, i + m, n - m, cmp)
    merge(mut arr, mut tmp, i, i + m - 1, i + m, i + n - 1, cmp)
  }
}

fun sort(mut arr, cmp) {
  let n = length(arr)
  let mut tmp = init(n, 0)
  merge_sort(mut arr, mut tmp, 0, n, cmp)
}

fun remove(mut arr, i) {
  if i >= length(arr) { option/None }
  else {
    -- move selected item to end
    swap_items(mut arr, i, length(arr) - 1)
    -- if we remove the last, or second-to-last item everything is already in
    -- order
    if length(arr) - i > 2 {
      -- swap remaining items
      iter_range(i, length(arr) - 2, fun i {
        swap_items(mut arr, i, i + 1)
      })
    }
    -- return removed item
    pop_back(mut arr)
  }
}

module fixed {
  let get = __fixed_array_get
  let length = __fixed_array_length
  let data = __fixed_array_data

  fun swap_items(mut arr, i, j) {
    if not (i == j) {
      let itmp = mov arr#[i]
      mut arr#[i] = arr#[j]
      mut arr#[j] = itmp
    }
  }

  fun reverse(mut arr) {
    let length = length(arr)
    iter_range(0, length / 2, fun i {
      swap_items(mut arr, i, length - i - 1)
    })
  }
}
