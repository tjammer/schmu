prog: With
##
## Ends in an error in state: 0.
##
## prog' -> . prog [ # ]
##
## The known suffix of the stack is as follows:
##
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Use With
##
## Ends in an error in state: 1.
##
## stmt_no_ident -> Use . use_path [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Use
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Use Path_id With
##
## Ends in an error in state: 2.
##
## use_path -> Path_id . use_path [ Semicolon Rpar Rcurly Lpar Lcurly Equal Eof Comma ]
##
## The known suffix of the stack is as follows:
## Path_id
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type With
##
## Ends in an error in state: 8.
##
## typedef -> Type . decl_typename Equal Lcurly separated_nonempty_trailing_list(Comma,record_item_decl,Rcurly) [ Semicolon Rcurly Eof ]
## typedef -> Type . decl_typename Equal type_spec [ Semicolon Rcurly Eof ]
## typedef -> Type . decl_typename Equal separated_nonempty_list(Hbar,ctor) [ Semicolon Rcurly Eof ]
## typedef -> Type . decl_typename Equal Hbar separated_nonempty_list(Hbar,ctor) [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type Ident With
##
## Ends in an error in state: 9.
##
## decl_typename -> Ident . [ Semicolon Rcurly Equal ]
## decl_typename -> Ident . Lbrack separated_nonempty_list(Comma,poly_id) Rbrack [ Semicolon Rcurly Equal ]
##
## The known suffix of the stack is as follows:
## Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type Ident Lbrack With
##
## Ends in an error in state: 10.
##
## decl_typename -> Ident Lbrack . separated_nonempty_list(Comma,poly_id) Rbrack [ Semicolon Rcurly Equal ]
##
## The known suffix of the stack is as follows:
## Ident Lbrack
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Quote With
##
## Ends in an error in state: 11.
##
## poly_id -> Quote . Ident [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## Quote
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type Ident Lbrack Quote Ident With
##
## Ends in an error in state: 15.
##
## separated_nonempty_list(Comma,poly_id) -> poly_id . [ Rbrack ]
## separated_nonempty_list(Comma,poly_id) -> poly_id . Comma separated_nonempty_list(Comma,poly_id) [ Rbrack ]
##
## The known suffix of the stack is as follows:
## poly_id
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type Ident Lbrack Quote Ident Comma With
##
## Ends in an error in state: 16.
##
## separated_nonempty_list(Comma,poly_id) -> poly_id Comma . separated_nonempty_list(Comma,poly_id) [ Rbrack ]
##
## The known suffix of the stack is as follows:
## poly_id Comma
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type Ident Semicolon
##
## Ends in an error in state: 18.
##
## typedef -> Type decl_typename . Equal Lcurly separated_nonempty_trailing_list(Comma,record_item_decl,Rcurly) [ Semicolon Rcurly Eof ]
## typedef -> Type decl_typename . Equal type_spec [ Semicolon Rcurly Eof ]
## typedef -> Type decl_typename . Equal separated_nonempty_list(Hbar,ctor) [ Semicolon Rcurly Eof ]
## typedef -> Type decl_typename . Equal Hbar separated_nonempty_list(Hbar,ctor) [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Type decl_typename
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 9, spurious reduction of production decl_typename -> Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type Ident Equal With
##
## Ends in an error in state: 19.
##
## typedef -> Type decl_typename Equal . Lcurly separated_nonempty_trailing_list(Comma,record_item_decl,Rcurly) [ Semicolon Rcurly Eof ]
## typedef -> Type decl_typename Equal . type_spec [ Semicolon Rcurly Eof ]
## typedef -> Type decl_typename Equal . separated_nonempty_list(Hbar,ctor) [ Semicolon Rcurly Eof ]
## typedef -> Type decl_typename Equal . Hbar separated_nonempty_list(Hbar,ctor) [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Type decl_typename Equal
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Path_id With
##
## Ends in an error in state: 20.
##
## type_path -> Path_id . type_path_cont [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## Path_id
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Path_id Path_id With
##
## Ends in an error in state: 21.
##
## type_path_cont -> Path_id . type_path_cont [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## Path_id
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar With
##
## Ends in an error in state: 25.
##
## type_spec -> Lpar . Rpar Right_arrow type_spec [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## type_spec -> Lpar . tup_or_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## Lpar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Rpar With
##
## Ends in an error in state: 26.
##
## type_spec -> Lpar Rpar . Right_arrow type_spec [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## Lpar Rpar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Rpar Right_arrow With
##
## Ends in an error in state: 27.
##
## type_spec -> Lpar Rpar Right_arrow . type_spec [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## Lpar Rpar Right_arrow
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Ident With
##
## Ends in an error in state: 28.
##
## ident -> Ident . [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## type_spec -> Ident . Hash Int [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## type_spec -> Ident . Hash_quest [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Ident Hash With
##
## Ends in an error in state: 30.
##
## type_spec -> Ident Hash . Int [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## Ident Hash
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Rpar Right_arrow Quote Ident With
##
## Ends in an error in state: 32.
##
## type_spec -> type_spec . Lbrack separated_nonempty_list(Comma,type_spec) Rbrack [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## type_spec -> Lpar Rpar Right_arrow type_spec . [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## Lpar Rpar Right_arrow type_spec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Ident Lbrack With
##
## Ends in an error in state: 33.
##
## type_spec -> type_spec Lbrack . separated_nonempty_list(Comma,type_spec) Rbrack [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## type_spec Lbrack
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Ident Lbrack Ident Semicolon
##
## Ends in an error in state: 34.
##
## separated_nonempty_list(Comma,type_spec) -> type_spec . [ Rpar Rbrack ]
## separated_nonempty_list(Comma,type_spec) -> type_spec . Comma separated_nonempty_list(Comma,type_spec) [ Rpar Rbrack ]
## type_spec -> type_spec . Lbrack separated_nonempty_list(Comma,type_spec) Rbrack [ Rpar Rbrack Lbrack Comma ]
##
## The known suffix of the stack is as follows:
## type_spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production ident -> Ident
## In state 39, spurious reduction of production type_spec -> ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Ident Lbrack Ident Comma With
##
## Ends in an error in state: 35.
##
## separated_nonempty_list(Comma,type_spec) -> type_spec Comma . separated_nonempty_list(Comma,type_spec) [ Rpar Rbrack ]
##
## The known suffix of the stack is as follows:
## type_spec Comma
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Ident Lbrack Ident Rpar
##
## Ends in an error in state: 40.
##
## type_spec -> type_spec Lbrack separated_nonempty_list(Comma,type_spec) . Rbrack [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## type_spec Lbrack separated_nonempty_list(Comma,type_spec)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production ident -> Ident
## In state 39, spurious reduction of production type_spec -> ident
## In state 34, spurious reduction of production separated_nonempty_list(Comma,type_spec) -> type_spec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Semicolon
##
## Ends in an error in state: 42.
##
## tup_or_fun -> type_spec . Rpar Right_arrow type_spec [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## tup_or_fun -> type_spec . Ampersand continue_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## tup_or_fun -> type_spec . Exclamation continue_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## tup_or_fun -> type_spec . Comma type_spec Ampersand continue_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## tup_or_fun -> type_spec . Comma type_spec Exclamation continue_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## tup_or_fun -> type_spec . Comma type_spec continue_tup_or_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## type_spec -> type_spec . Lbrack separated_nonempty_list(Comma,type_spec) Rbrack [ Rpar Lbrack Exclamation Comma Ampersand ]
##
## The known suffix of the stack is as follows:
## type_spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production ident -> Ident
## In state 39, spurious reduction of production type_spec -> ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Rpar With
##
## Ends in an error in state: 43.
##
## tup_or_fun -> type_spec Rpar . Right_arrow type_spec [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## type_spec Rpar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Rpar Right_arrow With
##
## Ends in an error in state: 44.
##
## tup_or_fun -> type_spec Rpar Right_arrow . type_spec [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## type_spec Rpar Right_arrow
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Rpar Right_arrow Quote Ident With
##
## Ends in an error in state: 45.
##
## tup_or_fun -> type_spec Rpar Right_arrow type_spec . [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## type_spec -> type_spec . Lbrack separated_nonempty_list(Comma,type_spec) Rbrack [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## type_spec Rpar Right_arrow type_spec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Exclamation With
##
## Ends in an error in state: 46.
##
## tup_or_fun -> type_spec Exclamation . continue_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## type_spec Exclamation
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Ampersand Rpar With
##
## Ends in an error in state: 47.
##
## continue_fun -> Rpar . Right_arrow type_spec [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## Rpar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Ampersand Rpar Right_arrow With
##
## Ends in an error in state: 48.
##
## continue_fun -> Rpar Right_arrow . type_spec [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## Rpar Right_arrow
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Ampersand Rpar Right_arrow Quote Ident With
##
## Ends in an error in state: 49.
##
## continue_fun -> Rpar Right_arrow type_spec . [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## type_spec -> type_spec . Lbrack separated_nonempty_list(Comma,type_spec) Rbrack [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## Rpar Right_arrow type_spec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Ampersand Comma With
##
## Ends in an error in state: 50.
##
## continue_fun -> Comma . type_spec option(decl_attr) continue_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## Comma
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Ampersand Comma Ident Semicolon
##
## Ends in an error in state: 51.
##
## continue_fun -> Comma type_spec . option(decl_attr) continue_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## type_spec -> type_spec . Lbrack separated_nonempty_list(Comma,type_spec) Rbrack [ Rpar Lbrack Exclamation Comma Ampersand ]
##
## The known suffix of the stack is as follows:
## Comma type_spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production ident -> Ident
## In state 39, spurious reduction of production type_spec -> ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Ampersand Comma Ident Ampersand With
##
## Ends in an error in state: 54.
##
## continue_fun -> Comma type_spec option(decl_attr) . continue_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## Comma type_spec option(decl_attr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Comma With
##
## Ends in an error in state: 57.
##
## tup_or_fun -> type_spec Comma . type_spec Ampersand continue_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## tup_or_fun -> type_spec Comma . type_spec Exclamation continue_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## tup_or_fun -> type_spec Comma . type_spec continue_tup_or_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## type_spec Comma
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Comma Ident Semicolon
##
## Ends in an error in state: 58.
##
## tup_or_fun -> type_spec Comma type_spec . Ampersand continue_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## tup_or_fun -> type_spec Comma type_spec . Exclamation continue_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## tup_or_fun -> type_spec Comma type_spec . continue_tup_or_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## type_spec -> type_spec . Lbrack separated_nonempty_list(Comma,type_spec) Rbrack [ Rpar Lbrack Exclamation Comma Ampersand ]
##
## The known suffix of the stack is as follows:
## type_spec Comma type_spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production ident -> Ident
## In state 39, spurious reduction of production type_spec -> ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Comma Ident Rpar With
##
## Ends in an error in state: 59.
##
## continue_tup_or_fun -> Rpar . [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## continue_tup_or_fun -> Rpar . Right_arrow type_spec [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## Rpar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Comma Ident Rpar Right_arrow With
##
## Ends in an error in state: 60.
##
## continue_tup_or_fun -> Rpar Right_arrow . type_spec [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## Rpar Right_arrow
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Comma Ident Rpar Right_arrow Quote Ident With
##
## Ends in an error in state: 61.
##
## continue_tup_or_fun -> Rpar Right_arrow type_spec . [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## type_spec -> type_spec . Lbrack separated_nonempty_list(Comma,type_spec) Rbrack [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## Rpar Right_arrow type_spec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Comma Ident Exclamation With
##
## Ends in an error in state: 62.
##
## tup_or_fun -> type_spec Comma type_spec Exclamation . continue_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## type_spec Comma type_spec Exclamation
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Comma Ident Comma With
##
## Ends in an error in state: 64.
##
## continue_tup_or_fun -> Comma . type_spec continue_tup_or_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## continue_tup_or_fun -> Comma . type_spec Ampersand continue_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## continue_tup_or_fun -> Comma . type_spec Exclamation continue_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## Comma
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Comma Ident Comma Ident Semicolon
##
## Ends in an error in state: 65.
##
## continue_tup_or_fun -> Comma type_spec . continue_tup_or_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## continue_tup_or_fun -> Comma type_spec . Ampersand continue_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## continue_tup_or_fun -> Comma type_spec . Exclamation continue_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
## type_spec -> type_spec . Lbrack separated_nonempty_list(Comma,type_spec) Rbrack [ Rpar Lbrack Exclamation Comma Ampersand ]
##
## The known suffix of the stack is as follows:
## Comma type_spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production ident -> Ident
## In state 39, spurious reduction of production type_spec -> ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Comma Ident Comma Ident Exclamation With
##
## Ends in an error in state: 66.
##
## continue_tup_or_fun -> Comma type_spec Exclamation . continue_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## Comma type_spec Exclamation
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Comma Ident Comma Ident Ampersand With
##
## Ends in an error in state: 68.
##
## continue_tup_or_fun -> Comma type_spec Ampersand . continue_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## Comma type_spec Ampersand
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Comma Ident Ampersand With
##
## Ends in an error in state: 71.
##
## tup_or_fun -> type_spec Comma type_spec Ampersand . continue_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## type_spec Comma type_spec Ampersand
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Lpar Ident Ampersand With
##
## Ends in an error in state: 74.
##
## tup_or_fun -> type_spec Ampersand . continue_fun [ Semicolon Rpar Rcurly Rbrack Lcurly Lbrack Exclamation Equal Eof Comma Colon Ampersand ]
##
## The known suffix of the stack is as follows:
## type_spec Ampersand
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type Ident Equal Lcurly With
##
## Ends in an error in state: 77.
##
## typedef -> Type decl_typename Equal Lcurly . separated_nonempty_trailing_list(Comma,record_item_decl,Rcurly) [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Type decl_typename Equal Lcurly
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type Ident Equal Lcurly Ident With
##
## Ends in an error in state: 78.
##
## record_item_decl -> Ident . boption(Ampersand) Colon type_spec [ Rcurly Comma ]
##
## The known suffix of the stack is as follows:
## Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type Ident Equal Lcurly Ident Ampersand With
##
## Ends in an error in state: 80.
##
## record_item_decl -> Ident boption(Ampersand) . Colon type_spec [ Rcurly Comma ]
##
## The known suffix of the stack is as follows:
## Ident boption(Ampersand)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type Ident Equal Lcurly Ident Colon With
##
## Ends in an error in state: 81.
##
## record_item_decl -> Ident boption(Ampersand) Colon . type_spec [ Rcurly Comma ]
##
## The known suffix of the stack is as follows:
## Ident boption(Ampersand) Colon
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type Ident Equal Lcurly Ident Colon Ident Semicolon
##
## Ends in an error in state: 82.
##
## record_item_decl -> Ident boption(Ampersand) Colon type_spec . [ Rcurly Comma ]
## type_spec -> type_spec . Lbrack separated_nonempty_list(Comma,type_spec) Rbrack [ Rcurly Lbrack Comma ]
##
## The known suffix of the stack is as follows:
## Ident boption(Ampersand) Colon type_spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production ident -> Ident
## In state 39, spurious reduction of production type_spec -> ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type Ident Equal Lcurly Ident Colon Ident Comma With
##
## Ends in an error in state: 85.
##
## option(Comma) -> Comma . [ Rcurly ]
## separated_nonempty_trailing_list(Comma,record_item_decl,Rcurly) -> record_item_decl Comma . separated_nonempty_trailing_list(Comma,record_item_decl,Rcurly) [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## record_item_decl Comma
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type Ident Equal Hbar With
##
## Ends in an error in state: 89.
##
## typedef -> Type decl_typename Equal Hbar . separated_nonempty_list(Hbar,ctor) [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Type decl_typename Equal Hbar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type Ident Equal Ctor With
##
## Ends in an error in state: 90.
##
## ctor -> Ctor . [ Semicolon Rcurly Hbar Eof ]
## ctor -> Ctor . Lpar ctor_type_spec Rpar [ Semicolon Rcurly Hbar Eof ]
## ctor -> Ctor . Lpar Int Rpar [ Semicolon Rcurly Hbar Eof ]
##
## The known suffix of the stack is as follows:
## Ctor
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type Ident Equal Ctor Lpar With
##
## Ends in an error in state: 91.
##
## ctor -> Ctor Lpar . ctor_type_spec Rpar [ Semicolon Rcurly Hbar Eof ]
## ctor -> Ctor Lpar . Int Rpar [ Semicolon Rcurly Hbar Eof ]
##
## The known suffix of the stack is as follows:
## Ctor Lpar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type Ident Equal Ctor Lpar Int With
##
## Ends in an error in state: 92.
##
## ctor -> Ctor Lpar Int . Rpar [ Semicolon Rcurly Hbar Eof ]
##
## The known suffix of the stack is as follows:
## Ctor Lpar Int
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type Ident Equal Ctor Lpar Ident Semicolon
##
## Ends in an error in state: 94.
##
## ctor_type_spec -> type_spec . [ Rpar ]
## ctor_type_spec -> type_spec . Comma separated_nonempty_list(Comma,type_spec) [ Rpar ]
## type_spec -> type_spec . Lbrack separated_nonempty_list(Comma,type_spec) Rbrack [ Rpar Lbrack Comma ]
##
## The known suffix of the stack is as follows:
## type_spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production ident -> Ident
## In state 39, spurious reduction of production type_spec -> ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type Ident Equal Ctor Lpar Ident Comma With
##
## Ends in an error in state: 95.
##
## ctor_type_spec -> type_spec Comma . separated_nonempty_list(Comma,type_spec) [ Rpar ]
##
## The known suffix of the stack is as follows:
## type_spec Comma
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type Ident Equal Ctor Lpar Ident Comma Ident Rbrack
##
## Ends in an error in state: 97.
##
## ctor -> Ctor Lpar ctor_type_spec . Rpar [ Semicolon Rcurly Hbar Eof ]
##
## The known suffix of the stack is as follows:
## Ctor Lpar ctor_type_spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production ident -> Ident
## In state 39, spurious reduction of production type_spec -> ident
## In state 34, spurious reduction of production separated_nonempty_list(Comma,type_spec) -> type_spec
## In state 96, spurious reduction of production ctor_type_spec -> type_spec Comma separated_nonempty_list(Comma,type_spec)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type Ident Equal Ctor Lpar Ident Rpar With
##
## Ends in an error in state: 100.
##
## separated_nonempty_list(Hbar,ctor) -> ctor . [ Semicolon Rcurly Eof ]
## separated_nonempty_list(Hbar,ctor) -> ctor . Hbar separated_nonempty_list(Hbar,ctor) [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## ctor
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type Ident Equal Ctor Hbar With
##
## Ends in an error in state: 101.
##
## separated_nonempty_list(Hbar,ctor) -> ctor Hbar . separated_nonempty_list(Hbar,ctor) [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## ctor Hbar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Type Ident Equal Ident Rpar
##
## Ends in an error in state: 103.
##
## type_spec -> type_spec . Lbrack separated_nonempty_list(Comma,type_spec) Rbrack [ Semicolon Rcurly Lbrack Eof ]
## typedef -> Type decl_typename Equal type_spec . [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Type decl_typename Equal type_spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production ident -> Ident
## In state 39, spurious reduction of production type_spec -> ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Signature With
##
## Ends in an error in state: 107.
##
## signature -> Signature . Lcurly sig_items Rcurly [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Signature
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Signature Lcurly With
##
## Ends in an error in state: 108.
##
## signature -> Signature Lcurly . sig_items Rcurly [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Signature Lcurly
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Signature Lcurly Val With
##
## Ends in an error in state: 109.
##
## sig_item -> Val . ident Colon type_spec [ Semicolon Rcurly ]
## sig_item -> Val . Eq_op Colon type_spec [ Semicolon Rcurly ]
## sig_item -> Val . Cmp_op Colon type_spec [ Semicolon Rcurly ]
## sig_item -> Val . Plus_op Colon type_spec [ Semicolon Rcurly ]
## sig_item -> Val . Mult_op Colon type_spec [ Semicolon Rcurly ]
##
## The known suffix of the stack is as follows:
## Val
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Signature Lcurly Val Plus_op With
##
## Ends in an error in state: 110.
##
## sig_item -> Val Plus_op . Colon type_spec [ Semicolon Rcurly ]
##
## The known suffix of the stack is as follows:
## Val Plus_op
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Signature Lcurly Val Plus_op Colon With
##
## Ends in an error in state: 111.
##
## sig_item -> Val Plus_op Colon . type_spec [ Semicolon Rcurly ]
##
## The known suffix of the stack is as follows:
## Val Plus_op Colon
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Signature Lcurly Val Plus_op Colon Ident Rpar
##
## Ends in an error in state: 112.
##
## sig_item -> Val Plus_op Colon type_spec . [ Semicolon Rcurly ]
## type_spec -> type_spec . Lbrack separated_nonempty_list(Comma,type_spec) Rbrack [ Semicolon Rcurly Lbrack ]
##
## The known suffix of the stack is as follows:
## Val Plus_op Colon type_spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production ident -> Ident
## In state 39, spurious reduction of production type_spec -> ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Signature Lcurly Val Mult_op With
##
## Ends in an error in state: 113.
##
## sig_item -> Val Mult_op . Colon type_spec [ Semicolon Rcurly ]
##
## The known suffix of the stack is as follows:
## Val Mult_op
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Signature Lcurly Val Mult_op Colon With
##
## Ends in an error in state: 114.
##
## sig_item -> Val Mult_op Colon . type_spec [ Semicolon Rcurly ]
##
## The known suffix of the stack is as follows:
## Val Mult_op Colon
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Signature Lcurly Val Mult_op Colon Ident Rpar
##
## Ends in an error in state: 115.
##
## sig_item -> Val Mult_op Colon type_spec . [ Semicolon Rcurly ]
## type_spec -> type_spec . Lbrack separated_nonempty_list(Comma,type_spec) Rbrack [ Semicolon Rcurly Lbrack ]
##
## The known suffix of the stack is as follows:
## Val Mult_op Colon type_spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production ident -> Ident
## In state 39, spurious reduction of production type_spec -> ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Signature Lcurly Val Eq_op With
##
## Ends in an error in state: 117.
##
## sig_item -> Val Eq_op . Colon type_spec [ Semicolon Rcurly ]
##
## The known suffix of the stack is as follows:
## Val Eq_op
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Signature Lcurly Val Eq_op Colon With
##
## Ends in an error in state: 118.
##
## sig_item -> Val Eq_op Colon . type_spec [ Semicolon Rcurly ]
##
## The known suffix of the stack is as follows:
## Val Eq_op Colon
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Signature Lcurly Val Eq_op Colon Ident Rpar
##
## Ends in an error in state: 119.
##
## sig_item -> Val Eq_op Colon type_spec . [ Semicolon Rcurly ]
## type_spec -> type_spec . Lbrack separated_nonempty_list(Comma,type_spec) Rbrack [ Semicolon Rcurly Lbrack ]
##
## The known suffix of the stack is as follows:
## Val Eq_op Colon type_spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production ident -> Ident
## In state 39, spurious reduction of production type_spec -> ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Signature Lcurly Val Cmp_op With
##
## Ends in an error in state: 120.
##
## sig_item -> Val Cmp_op . Colon type_spec [ Semicolon Rcurly ]
##
## The known suffix of the stack is as follows:
## Val Cmp_op
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Signature Lcurly Val Cmp_op Colon With
##
## Ends in an error in state: 121.
##
## sig_item -> Val Cmp_op Colon . type_spec [ Semicolon Rcurly ]
##
## The known suffix of the stack is as follows:
## Val Cmp_op Colon
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Signature Lcurly Val Cmp_op Colon Ident Rpar
##
## Ends in an error in state: 122.
##
## sig_item -> Val Cmp_op Colon type_spec . [ Semicolon Rcurly ]
## type_spec -> type_spec . Lbrack separated_nonempty_list(Comma,type_spec) Rbrack [ Semicolon Rcurly Lbrack ]
##
## The known suffix of the stack is as follows:
## Val Cmp_op Colon type_spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production ident -> Ident
## In state 39, spurious reduction of production type_spec -> ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Signature Lcurly Val Ident With
##
## Ends in an error in state: 123.
##
## sig_item -> Val ident . Colon type_spec [ Semicolon Rcurly ]
##
## The known suffix of the stack is as follows:
## Val ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Signature Lcurly Val Ident Colon With
##
## Ends in an error in state: 124.
##
## sig_item -> Val ident Colon . type_spec [ Semicolon Rcurly ]
##
## The known suffix of the stack is as follows:
## Val ident Colon
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Signature Lcurly Val Ident Colon Ident Rpar
##
## Ends in an error in state: 125.
##
## sig_item -> Val ident Colon type_spec . [ Semicolon Rcurly ]
## type_spec -> type_spec . Lbrack separated_nonempty_list(Comma,type_spec) Rbrack [ Semicolon Rcurly Lbrack ]
##
## The known suffix of the stack is as follows:
## Val ident Colon type_spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production ident -> Ident
## In state 39, spurious reduction of production type_spec -> ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Signature Lcurly Type With
##
## Ends in an error in state: 126.
##
## sig_item -> Type . decl_typename [ Semicolon Rcurly ]
## typedef -> Type . decl_typename Equal Lcurly separated_nonempty_trailing_list(Comma,record_item_decl,Rcurly) [ Semicolon Rcurly ]
## typedef -> Type . decl_typename Equal type_spec [ Semicolon Rcurly ]
## typedef -> Type . decl_typename Equal separated_nonempty_list(Hbar,ctor) [ Semicolon Rcurly ]
## typedef -> Type . decl_typename Equal Hbar separated_nonempty_list(Hbar,ctor) [ Semicolon Rcurly ]
##
## The known suffix of the stack is as follows:
## Type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Signature Lcurly Type Ident Lbrack Quote Ident Rbrack With
##
## Ends in an error in state: 127.
##
## sig_item -> Type decl_typename . [ Semicolon Rcurly ]
## typedef -> Type decl_typename . Equal Lcurly separated_nonempty_trailing_list(Comma,record_item_decl,Rcurly) [ Semicolon Rcurly ]
## typedef -> Type decl_typename . Equal type_spec [ Semicolon Rcurly ]
## typedef -> Type decl_typename . Equal separated_nonempty_list(Hbar,ctor) [ Semicolon Rcurly ]
## typedef -> Type decl_typename . Equal Hbar separated_nonempty_list(Hbar,ctor) [ Semicolon Rcurly ]
##
## The known suffix of the stack is as follows:
## Type decl_typename
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Signature Lcurly Type Ident Equal Ctor Eof
##
## Ends in an error in state: 131.
##
## separated_nonempty_list(Semicolon,sig_item) -> sig_item . [ Rcurly ]
## separated_nonempty_list(Semicolon,sig_item) -> sig_item . Semicolon separated_nonempty_list(Semicolon,sig_item) [ Rcurly ]
##
## The known suffix of the stack is as follows:
## sig_item
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 90, spurious reduction of production ctor -> Ctor
## In state 100, spurious reduction of production separated_nonempty_list(Hbar,ctor) -> ctor
## In state 104, spurious reduction of production typedef -> Type decl_typename Equal separated_nonempty_list(Hbar,ctor)
## In state 128, spurious reduction of production sig_item -> typedef
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Signature Lcurly Type Ident Semicolon With
##
## Ends in an error in state: 132.
##
## separated_nonempty_list(Semicolon,sig_item) -> sig_item Semicolon . separated_nonempty_list(Semicolon,sig_item) [ Rcurly ]
##
## The known suffix of the stack is as follows:
## sig_item Semicolon
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Plus_op Wildcard
##
## Ends in an error in state: 135.
##
## expr_no_ident -> Plus_op . [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> Plus_op . expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Plus_op
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Path_id With
##
## Ends in an error in state: 136.
##
## expr_no_ident -> Path_id . expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Path_id
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Match With
##
## Ends in an error in state: 138.
##
## expr_no_ident -> Match . passed(expr) Lcurly clauses Rcurly [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Match
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Lpar With
##
## Ends in an error in state: 139.
##
## expr_no_ident -> Lpar . tuple Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> Lpar . expr Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## lit -> Lpar . Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Lpar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Lcurly With
##
## Ends in an error in state: 141.
##
## expr_no_ident -> Lcurly . separated_nonempty_trailing_list(Comma,record_item,Rcurly) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> Lcurly . stmt_no_ident block_cont [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> Lcurly . expr With separated_nonempty_trailing_list(Comma,record_item,Rcurly) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Lcurly
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Let With
##
## Ends in an error in state: 142.
##
## stmt_no_ident -> Let . let_decl Equal passed(expr) [ Semicolon Rcurly Eof ]
## stmt_no_ident -> Let . let_decl Equal Builtin_id [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Let
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Wildcard Wildcard
##
## Ends in an error in state: 143.
##
## basic_pattern -> Wildcard . [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Lbrack Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## basic_pattern -> Wildcard . Exclamation [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Lbrack Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## basic_pattern -> Wildcard . Ampersand [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Lbrack Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Wildcard
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Let Lpar With
##
## Ends in an error in state: 149.
##
## pattern -> Lpar . pattern Hbar separated_nonempty_list(Hbar,pattern) Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## tup_patterns -> Lpar . tup_tups(pattern) Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## tup_patterns -> Lpar . tup_tups(pattern) Rpar Ampersand [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## tup_patterns -> Lpar . tup_tups(pattern) Rpar Exclamation [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Lpar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Lcurly With
##
## Ends in an error in state: 150.
##
## record_pattern(pattern) -> Lcurly . separated_nonempty_trailing_list(Comma,record_item_pattern(pattern),Rcurly) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Lbrack Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Lcurly
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Lcurly Ident Equal Cmp_op Wildcard
##
## Ends in an error in state: 152.
##
## separated_nonempty_trailing_list(Comma,record_item_pattern(pattern),Rcurly) -> record_item_pattern(pattern) . option(Comma) Rcurly [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Lbrack Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## separated_nonempty_trailing_list(Comma,record_item_pattern(pattern),Rcurly) -> record_item_pattern(pattern) . Comma separated_nonempty_trailing_list(Comma,record_item_pattern(pattern),Rcurly) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Lbrack Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## record_item_pattern(pattern)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Lcurly Ident Comma With
##
## Ends in an error in state: 153.
##
## option(Comma) -> Comma . [ Rcurly ]
## separated_nonempty_trailing_list(Comma,record_item_pattern(pattern),Rcurly) -> record_item_pattern(pattern) Comma . separated_nonempty_trailing_list(Comma,record_item_pattern(pattern),Rcurly) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Lbrack Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## record_item_pattern(pattern) Comma
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Lcurly Ident With
##
## Ends in an error in state: 155.
##
## record_item_pattern(pattern) -> ident . Equal pattern [ Rcurly Comma ]
## record_item_pattern(pattern) -> ident . [ Rcurly Comma ]
##
## The known suffix of the stack is as follows:
## ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Lcurly Ident Equal With
##
## Ends in an error in state: 156.
##
## record_item_pattern(pattern) -> ident Equal . pattern [ Rcurly Comma ]
##
## The known suffix of the stack is as follows:
## ident Equal
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Ctor Wildcard
##
## Ends in an error in state: 159.
##
## basic_pattern -> Ctor . [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Lbrack Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## basic_pattern -> Ctor . Lpar pattern Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Lbrack Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## basic_pattern -> Ctor . Lpar inner_tup_pattern(pattern) Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Lbrack Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Ctor
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Ctor Lpar With
##
## Ends in an error in state: 160.
##
## basic_pattern -> Ctor Lpar . pattern Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Lbrack Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## basic_pattern -> Ctor Lpar . inner_tup_pattern(pattern) Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Lbrack Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Ctor Lpar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Let Ident Comma With
##
## Ends in an error in state: 163.
##
## tup_tups(pattern) -> with_loc(pattern) Comma . separated_nonempty_list(Comma,with_loc(pattern)) [ Rpar Equal Colon ]
##
## The known suffix of the stack is as follows:
## with_loc(pattern) Comma
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Let Ident Comma Cmp_op Wildcard
##
## Ends in an error in state: 164.
##
## separated_nonempty_list(Comma,with_loc(pattern)) -> with_loc(pattern) . [ Rpar Equal Colon ]
## separated_nonempty_list(Comma,with_loc(pattern)) -> with_loc(pattern) . Comma separated_nonempty_list(Comma,with_loc(pattern)) [ Rpar Equal Colon ]
##
## The known suffix of the stack is as follows:
## with_loc(pattern)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Let Ident Comma Ident Comma With
##
## Ends in an error in state: 165.
##
## separated_nonempty_list(Comma,with_loc(pattern)) -> with_loc(pattern) Comma . separated_nonempty_list(Comma,with_loc(pattern)) [ Rpar Equal Colon ]
##
## The known suffix of the stack is as follows:
## with_loc(pattern) Comma
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Let Ident Wildcard
##
## Ends in an error in state: 170.
##
## basic_pattern -> ident . [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Lbrack Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## basic_pattern -> ident . Ampersand [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Lbrack Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## basic_pattern -> ident . Exclamation [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Lbrack Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Ctor Lpar Cmp_op Wildcard
##
## Ends in an error in state: 176.
##
## basic_pattern -> Ctor Lpar pattern . Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Lbrack Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## with_loc(pattern) -> pattern . [ Comma ]
##
## The known suffix of the stack is as follows:
## Ctor Lpar pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Ctor Lpar Ident Comma Ident Equal
##
## Ends in an error in state: 178.
##
## basic_pattern -> Ctor Lpar inner_tup_pattern(pattern) . Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Lbrack Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Ctor Lpar inner_tup_pattern(pattern)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 170, spurious reduction of production basic_pattern -> ident
## In state 173, spurious reduction of production pattern -> basic_pattern
## In state 169, spurious reduction of production with_loc(pattern) -> pattern
## In state 164, spurious reduction of production separated_nonempty_list(Comma,with_loc(pattern)) -> with_loc(pattern)
## In state 174, spurious reduction of production tup_tups(pattern) -> with_loc(pattern) Comma separated_nonempty_list(Comma,with_loc(pattern))
## In state 175, spurious reduction of production inner_tup_pattern(pattern) -> tup_tups(pattern)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Let Lpar Ident Comma Ident Equal
##
## Ends in an error in state: 183.
##
## tup_patterns -> Lpar tup_tups(pattern) . Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## tup_patterns -> Lpar tup_tups(pattern) . Rpar Ampersand [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## tup_patterns -> Lpar tup_tups(pattern) . Rpar Exclamation [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Lpar tup_tups(pattern)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 170, spurious reduction of production basic_pattern -> ident
## In state 173, spurious reduction of production pattern -> basic_pattern
## In state 169, spurious reduction of production with_loc(pattern) -> pattern
## In state 164, spurious reduction of production separated_nonempty_list(Comma,with_loc(pattern)) -> with_loc(pattern)
## In state 174, spurious reduction of production tup_tups(pattern) -> with_loc(pattern) Comma separated_nonempty_list(Comma,with_loc(pattern))
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Let Lpar Ident Comma Ident Rpar Wildcard
##
## Ends in an error in state: 184.
##
## tup_patterns -> Lpar tup_tups(pattern) Rpar . [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## tup_patterns -> Lpar tup_tups(pattern) Rpar . Ampersand [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## tup_patterns -> Lpar tup_tups(pattern) Rpar . Exclamation [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Lpar tup_tups(pattern) Rpar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Let Lpar Cmp_op Wildcard
##
## Ends in an error in state: 187.
##
## pattern -> Lpar pattern . Hbar separated_nonempty_list(Hbar,pattern) Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## with_loc(pattern) -> pattern . [ Comma ]
##
## The known suffix of the stack is as follows:
## Lpar pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Let Lpar Ident Hbar With
##
## Ends in an error in state: 188.
##
## pattern -> Lpar pattern Hbar . separated_nonempty_list(Hbar,pattern) Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Lpar pattern Hbar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Let Lpar Ident Hbar Ident Colon
##
## Ends in an error in state: 189.
##
## pattern -> Lpar pattern Hbar separated_nonempty_list(Hbar,pattern) . Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hbar Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Lpar pattern Hbar separated_nonempty_list(Hbar,pattern)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 170, spurious reduction of production basic_pattern -> ident
## In state 173, spurious reduction of production pattern -> basic_pattern
## In state 191, spurious reduction of production separated_nonempty_list(Hbar,pattern) -> pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Let Lpar Ident Hbar Cmp_op Wildcard
##
## Ends in an error in state: 191.
##
## separated_nonempty_list(Hbar,pattern) -> pattern . [ Rpar Colon And ]
## separated_nonempty_list(Hbar,pattern) -> pattern . Hbar separated_nonempty_list(Hbar,pattern) [ Rpar Colon And ]
##
## The known suffix of the stack is as follows:
## pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Let Lpar Ident Hbar Ident Hbar With
##
## Ends in an error in state: 192.
##
## separated_nonempty_list(Hbar,pattern) -> pattern Hbar . separated_nonempty_list(Hbar,pattern) [ Rpar Colon And ]
##
## The known suffix of the stack is as follows:
## pattern Hbar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Let Cmp_op Wildcard
##
## Ends in an error in state: 195.
##
## let_pattern -> pattern . [ Equal Colon ]
## with_loc(pattern) -> pattern . [ Comma ]
##
## The known suffix of the stack is as follows:
## pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Let Ident Comma Ident Rpar
##
## Ends in an error in state: 196.
##
## let_decl -> let_pattern . [ Equal ]
## let_decl -> let_pattern . Colon type_spec [ Equal ]
##
## The known suffix of the stack is as follows:
## let_pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 170, spurious reduction of production basic_pattern -> ident
## In state 173, spurious reduction of production pattern -> basic_pattern
## In state 169, spurious reduction of production with_loc(pattern) -> pattern
## In state 164, spurious reduction of production separated_nonempty_list(Comma,with_loc(pattern)) -> with_loc(pattern)
## In state 174, spurious reduction of production tup_tups(pattern) -> with_loc(pattern) Comma separated_nonempty_list(Comma,with_loc(pattern))
## In state 194, spurious reduction of production let_pattern -> tup_tups(pattern)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Let Ident Colon With
##
## Ends in an error in state: 197.
##
## let_decl -> let_pattern Colon . type_spec [ Equal ]
##
## The known suffix of the stack is as follows:
## let_pattern Colon
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Let Ident Colon Ident Semicolon
##
## Ends in an error in state: 198.
##
## let_decl -> let_pattern Colon type_spec . [ Equal ]
## type_spec -> type_spec . Lbrack separated_nonempty_list(Comma,type_spec) Rbrack [ Lbrack Equal ]
##
## The known suffix of the stack is as follows:
## let_pattern Colon type_spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production ident -> Ident
## In state 39, spurious reduction of production type_spec -> ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Let Ident Equal With
##
## Ends in an error in state: 200.
##
## stmt_no_ident -> Let let_decl Equal . passed(expr) [ Semicolon Rcurly Eof ]
## stmt_no_ident -> Let let_decl Equal . Builtin_id [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Let let_decl Equal
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Lbrack With
##
## Ends in an error in state: 201.
##
## array_lit -> Lbrack . separated_trailing_list(Comma,expr,Rbrack) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Lbrack
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: If With
##
## Ends in an error in state: 204.
##
## expr_no_ident -> If . expr block ifcont [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## If
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Hash With
##
## Ends in an error in state: 206.
##
## fixed_array_lit -> Hash . Lbrack separated_nonempty_trailing_list(Comma,expr,Rbrack) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## fixed_array_lit -> Hash . Int Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Hash
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Hash Lbrack With
##
## Ends in an error in state: 207.
##
## fixed_array_lit -> Hash Lbrack . separated_nonempty_trailing_list(Comma,expr,Rbrack) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Hash Lbrack
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Ampersand Fun With
##
## Ends in an error in state: 208.
##
## lambda -> Fun . parens(param_decl) loption(capture_copies) option(return_annot) block [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## lambda -> Fun . only_one_param loption(capture_copies) block [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## lambda -> Fun . parens(param_decl) loption(capture_copies) option(return_annot) Colon expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## lambda -> Fun . only_one_param loption(capture_copies) Colon expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Fun
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Lpar With
##
## Ends in an error in state: 209.
##
## parens(param_decl) -> Lpar . loption(separated_nonempty_list(Comma,param_decl)) Rpar [ Right_arrow Lcurly Lbrack Colon ]
##
## The known suffix of the stack is as follows:
## Lpar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Lpar Cmp_op Wildcard
##
## Ends in an error in state: 211.
##
## param_decl -> pattern . [ Rpar Comma ]
## param_decl -> pattern . Colon type_spec [ Rpar Comma ]
##
## The known suffix of the stack is as follows:
## pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Lpar Ident Colon With
##
## Ends in an error in state: 212.
##
## param_decl -> pattern Colon . type_spec [ Rpar Comma ]
##
## The known suffix of the stack is as follows:
## pattern Colon
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Lpar Ident Colon Ident Semicolon
##
## Ends in an error in state: 213.
##
## param_decl -> pattern Colon type_spec . [ Rpar Comma ]
## type_spec -> type_spec . Lbrack separated_nonempty_list(Comma,type_spec) Rbrack [ Rpar Lbrack Comma ]
##
## The known suffix of the stack is as follows:
## pattern Colon type_spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production ident -> Ident
## In state 39, spurious reduction of production type_spec -> ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Lpar Ident Comma With
##
## Ends in an error in state: 215.
##
## separated_nonempty_list(Comma,param_decl) -> param_decl Comma . separated_nonempty_list(Comma,param_decl) [ Rpar ]
##
## The known suffix of the stack is as follows:
## param_decl Comma
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Lpar Rpar With
##
## Ends in an error in state: 219.
##
## lambda -> Fun parens(param_decl) . loption(capture_copies) option(return_annot) block [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## lambda -> Fun parens(param_decl) . loption(capture_copies) option(return_annot) Colon expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Fun parens(param_decl)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Ident Lbrack With
##
## Ends in an error in state: 220.
##
## capture_copies -> Lbrack . separated_nonempty_list(Comma,ident) Rbrack [ Right_arrow Lcurly Colon ]
##
## The known suffix of the stack is as follows:
## Lbrack
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Ident Lbrack Ident With
##
## Ends in an error in state: 223.
##
## separated_nonempty_list(Comma,ident) -> ident . [ Rbrack ]
## separated_nonempty_list(Comma,ident) -> ident . Comma separated_nonempty_list(Comma,ident) [ Rbrack ]
##
## The known suffix of the stack is as follows:
## ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Ident Lbrack Ident Comma With
##
## Ends in an error in state: 224.
##
## separated_nonempty_list(Comma,ident) -> ident Comma . separated_nonempty_list(Comma,ident) [ Rbrack ]
##
## The known suffix of the stack is as follows:
## ident Comma
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Lpar Rpar Lbrack Ident Rbrack With
##
## Ends in an error in state: 226.
##
## lambda -> Fun parens(param_decl) loption(capture_copies) . option(return_annot) block [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## lambda -> Fun parens(param_decl) loption(capture_copies) . option(return_annot) Colon expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Fun parens(param_decl) loption(capture_copies)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Lpar Rpar Right_arrow With
##
## Ends in an error in state: 227.
##
## return_annot -> Right_arrow . type_spec [ Lcurly Colon ]
##
## The known suffix of the stack is as follows:
## Right_arrow
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Lpar Rpar Right_arrow Ident Semicolon
##
## Ends in an error in state: 228.
##
## return_annot -> Right_arrow type_spec . [ Lcurly Colon ]
## type_spec -> type_spec . Lbrack separated_nonempty_list(Comma,type_spec) Rbrack [ Lcurly Lbrack Colon ]
##
## The known suffix of the stack is as follows:
## Right_arrow type_spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production ident -> Ident
## In state 39, spurious reduction of production type_spec -> ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: If False Lcurly With
##
## Ends in an error in state: 231.
##
## block -> Lcurly . separated_nonempty_list(Semicolon,stmt) Rcurly [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Else Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Lcurly
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun With
##
## Ends in an error in state: 232.
##
## lambda -> Fun . parens(param_decl) loption(capture_copies) option(return_annot) block [ With Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## lambda -> Fun . only_one_param loption(capture_copies) block [ With Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## lambda -> Fun . parens(param_decl) loption(capture_copies) option(return_annot) Colon expr [ With Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## lambda -> Fun . only_one_param loption(capture_copies) Colon expr [ With Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## stmt_no_ident -> Fun . func [ Semicolon Rcurly Eof ]
## stmt_no_ident -> Fun . func_colon [ Semicolon Rcurly Eof ]
## stmt_no_ident -> Fun . Rec func [ Semicolon Rcurly Eof ]
## stmt_no_ident -> Fun . Rec func And separated_nonempty_list(And,func) [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Fun
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Rec With
##
## Ends in an error in state: 233.
##
## stmt_no_ident -> Fun Rec . func [ Semicolon Rcurly Eof ]
## stmt_no_ident -> Fun Rec . func And separated_nonempty_list(And,func) [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Fun Rec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Rec Ident With
##
## Ends in an error in state: 239.
##
## func -> func_name . parens(param_decl) loption(capture_copies) option(return_annot) block [ Semicolon Rcurly Eof And ]
##
## The known suffix of the stack is as follows:
## func_name
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Rec Ident Lpar Rpar With
##
## Ends in an error in state: 240.
##
## func -> func_name parens(param_decl) . loption(capture_copies) option(return_annot) block [ Semicolon Rcurly Eof And ]
##
## The known suffix of the stack is as follows:
## func_name parens(param_decl)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Rec Ident Lpar Rpar Lbrack Ident Rbrack With
##
## Ends in an error in state: 241.
##
## func -> func_name parens(param_decl) loption(capture_copies) . option(return_annot) block [ Semicolon Rcurly Eof And ]
##
## The known suffix of the stack is as follows:
## func_name parens(param_decl) loption(capture_copies)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Rec Ident Lpar Rpar Right_arrow Ident Colon
##
## Ends in an error in state: 242.
##
## func -> func_name parens(param_decl) loption(capture_copies) option(return_annot) . block [ Semicolon Rcurly Eof And ]
##
## The known suffix of the stack is as follows:
## func_name parens(param_decl) loption(capture_copies) option(return_annot)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production ident -> Ident
## In state 39, spurious reduction of production type_spec -> ident
## In state 228, spurious reduction of production return_annot -> Right_arrow type_spec
## In state 229, spurious reduction of production option(return_annot) -> return_annot
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Rec Ident Lpar Rpar Lcurly Ident Rcurly With
##
## Ends in an error in state: 245.
##
## stmt_no_ident -> Fun Rec func . [ Semicolon Rcurly Eof ]
## stmt_no_ident -> Fun Rec func . And separated_nonempty_list(And,func) [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Fun Rec func
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Rec Ident Lpar Rpar Lcurly Ident Rcurly And With
##
## Ends in an error in state: 246.
##
## stmt_no_ident -> Fun Rec func And . separated_nonempty_list(And,func) [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Fun Rec func And
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Rec Ident Lpar Rpar Lcurly Ident Rcurly And Ident Lpar Rpar Lcurly Ident Rcurly With
##
## Ends in an error in state: 248.
##
## separated_nonempty_list(And,func) -> func . [ Semicolon Rcurly Eof ]
## separated_nonempty_list(And,func) -> func . And separated_nonempty_list(And,func) [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## func
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Rec Ident Lpar Rpar Lcurly Ident Rcurly And Ident Lpar Rpar Lcurly Ident Rcurly And With
##
## Ends in an error in state: 249.
##
## separated_nonempty_list(And,func) -> func And . separated_nonempty_list(And,func) [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## func And
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Plus_op With
##
## Ends in an error in state: 251.
##
## basic_pattern -> Plus_op . [ Lcurly Lbrack Colon ]
## func_name -> Plus_op . [ Lpar ]
##
## The known suffix of the stack is as follows:
## Plus_op
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Mult_op With
##
## Ends in an error in state: 252.
##
## basic_pattern -> Mult_op . [ Lcurly Lbrack Colon ]
## func_name -> Mult_op . [ Lpar ]
##
## The known suffix of the stack is as follows:
## Mult_op
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Eq_op With
##
## Ends in an error in state: 253.
##
## basic_pattern -> Eq_op . [ Lcurly Lbrack Colon ]
## func_name -> Eq_op . [ Lpar ]
##
## The known suffix of the stack is as follows:
## Eq_op
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Cmp_op With
##
## Ends in an error in state: 254.
##
## basic_pattern -> Cmp_op . [ Lcurly Lbrack Colon ]
## func_name -> Cmp_op . [ Lpar ]
##
## The known suffix of the stack is as follows:
## Cmp_op
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Int Wildcard
##
## Ends in an error in state: 255.
##
## lambda -> Fun only_one_param . loption(capture_copies) block [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## lambda -> Fun only_one_param . loption(capture_copies) Colon expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Fun only_one_param
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Ident Lbrack Ident Rbrack With
##
## Ends in an error in state: 256.
##
## lambda -> Fun only_one_param loption(capture_copies) . block [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## lambda -> Fun only_one_param loption(capture_copies) . Colon expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Fun only_one_param loption(capture_copies)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Ident Colon With
##
## Ends in an error in state: 257.
##
## lambda -> Fun only_one_param loption(capture_copies) Colon . expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Fun only_one_param loption(capture_copies) Colon
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fmt With
##
## Ends in an error in state: 258.
##
## expr_no_ident -> Fmt . parens(expr) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Fmt
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fmt Lpar With
##
## Ends in an error in state: 259.
##
## parens(expr) -> Lpar . loption(separated_nonempty_list(Comma,expr)) Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Lpar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Ctor Wildcard
##
## Ends in an error in state: 264.
##
## upcases -> Ctor . [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## upcases -> Ctor . Lpar expr Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## upcases -> Ctor . Lpar tuple Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Ctor
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Ctor Lpar With
##
## Ends in an error in state: 265.
##
## upcases -> Ctor Lpar . expr Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## upcases -> Ctor Lpar . tuple Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Ctor Lpar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Builtin_id With
##
## Ends in an error in state: 267.
##
## expr_no_ident -> Builtin_id . parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Builtin_id
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Lpar With
##
## Ends in an error in state: 268.
##
## parens(call_arg) -> Lpar . loption(separated_nonempty_list(Comma,call_arg)) Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Lpar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Lpar Exclamation With
##
## Ends in an error in state: 269.
##
## call_arg -> Exclamation . expr [ Rpar Comma ]
##
## The known suffix of the stack is as follows:
## Exclamation
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Ampersand With
##
## Ends in an error in state: 270.
##
## expr_no_ident -> Ampersand . expr Equal expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Ampersand
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Ampersand False Wildcard
##
## Ends in an error in state: 278.
##
## expr_no_ident -> expr . And expr [ Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Or expr [ Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Cmp_op And ]
## expr_no_ident -> Ampersand expr . Equal expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Ampersand expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Plus_op With
##
## Ends in an error in state: 279.
##
## expr_no_ident -> expr Plus_op . expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Plus_op
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Plus_op False Wildcard
##
## Ends in an error in state: 280.
##
## expr_no_ident -> expr . And expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Or expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr Plus_op expr . [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Plus_op expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Mult_op With
##
## Ends in an error in state: 281.
##
## expr_no_ident -> expr Mult_op . expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Mult_op
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Mult_op False Wildcard
##
## Ends in an error in state: 282.
##
## expr_no_ident -> expr . And expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Or expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr Mult_op expr . [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Mult_op expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Hash With
##
## Ends in an error in state: 283.
##
## special_builtins -> expr Hash . Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Hash
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Hash Lbrack With
##
## Ends in an error in state: 284.
##
## special_builtins -> expr Hash Lbrack . expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Hash Lbrack
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Hash Lbrack False Wildcard
##
## Ends in an error in state: 285.
##
## expr_no_ident -> expr . And expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Or expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## special_builtins -> expr Hash Lbrack expr . Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Hash Lbrack expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Or With
##
## Ends in an error in state: 287.
##
## expr_no_ident -> expr Or . expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Or
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Or False Wildcard
##
## Ends in an error in state: 288.
##
## expr_no_ident -> expr . And expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Or expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr Or expr . [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Or expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Eq_op With
##
## Ends in an error in state: 289.
##
## expr_no_ident -> expr Eq_op . expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Eq_op
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Eq_op False Wildcard
##
## Ends in an error in state: 290.
##
## expr_no_ident -> expr . And expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Or expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr Eq_op expr . [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Eq_op expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Dot With
##
## Ends in an error in state: 291.
##
## expr_no_ident -> expr Dot . ident parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr Dot . path_ident parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr Dot . Lpar expr Rpar parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr Dot . Fmt parens(expr) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr Dot . ident [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr Dot . Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Dot
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Dot Path_id With
##
## Ends in an error in state: 292.
##
## nonempty_list(Path_id) -> Path_id . [ Wildcard U8 Plus_op Mult_op Lpar Lcurly Int Ident Eq_op Ctor Cmp_op ]
## nonempty_list(Path_id) -> Path_id . nonempty_list(Path_id) [ Wildcard U8 Plus_op Mult_op Lpar Lcurly Int Ident Eq_op Ctor Cmp_op ]
##
## The known suffix of the stack is as follows:
## Path_id
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Dot Lpar With
##
## Ends in an error in state: 294.
##
## expr_no_ident -> expr Dot Lpar . expr Rpar parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Dot Lpar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Dot Lpar False Wildcard
##
## Ends in an error in state: 295.
##
## expr_no_ident -> expr . And expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Or expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr Dot Lpar expr . Rpar parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Dot Lpar expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Dot Lpar False Rpar With
##
## Ends in an error in state: 296.
##
## expr_no_ident -> expr Dot Lpar expr Rpar . parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Dot Lpar expr Rpar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Matches With
##
## Ends in an error in state: 298.
##
## expr_no_ident -> expr Matches . pattern [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Matches
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Cmp_op With
##
## Ends in an error in state: 300.
##
## expr_no_ident -> expr Cmp_op . expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Cmp_op
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Cmp_op False Wildcard
##
## Ends in an error in state: 301.
##
## expr_no_ident -> expr . And expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Or expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr Cmp_op expr . [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Cmp_op expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False And With
##
## Ends in an error in state: 305.
##
## expr_no_ident -> expr And . expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr And
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False And False Wildcard
##
## Ends in an error in state: 306.
##
## expr_no_ident -> expr . And expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr And expr . [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Or expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr And expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Dot Lbrack With
##
## Ends in an error in state: 307.
##
## special_builtins -> expr Dot Lbrack . expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Dot Lbrack
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Dot Lbrack False Wildcard
##
## Ends in an error in state: 308.
##
## expr_no_ident -> expr . And expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Or expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## special_builtins -> expr Dot Lbrack expr . Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Dot Lbrack expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Dot Fmt With
##
## Ends in an error in state: 310.
##
## expr_no_ident -> expr Dot Fmt . parens(expr) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Dot Fmt
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Dot Path_id Ident With
##
## Ends in an error in state: 312.
##
## expr_no_ident -> expr Dot path_ident . parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Dot path_ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Dot Path_id Wildcard
##
## Ends in an error in state: 314.
##
## path_ident -> nonempty_list(Path_id) . ident [ Lpar ]
##
## The known suffix of the stack is as follows:
## nonempty_list(Path_id)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 292, spurious reduction of production nonempty_list(Path_id) -> Path_id
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Dot Ident Wildcard
##
## Ends in an error in state: 316.
##
## expr_no_ident -> expr Dot ident . parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr Dot ident . [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Dot ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Ampersand False Equal With
##
## Ends in an error in state: 318.
##
## expr_no_ident -> Ampersand expr Equal . expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Ampersand expr Equal
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Ampersand False Equal False Wildcard
##
## Ends in an error in state: 319.
##
## expr_no_ident -> expr . And expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Or expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> Ampersand expr Equal expr . [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Ampersand expr Equal expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Lpar Exclamation False Wildcard
##
## Ends in an error in state: 320.
##
## call_arg -> Exclamation expr . [ Rpar Comma ]
## expr_no_ident -> expr . And expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Or expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Exclamation expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Lpar Ampersand With
##
## Ends in an error in state: 321.
##
## call_arg -> Ampersand . expr [ Rpar Comma ]
## expr_no_ident -> Ampersand . expr Equal expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Ampersand
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Lpar Ampersand False Wildcard
##
## Ends in an error in state: 322.
##
## call_arg -> Ampersand expr . [ Rpar Comma ]
## expr_no_ident -> expr . And expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Or expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ Rpar Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ Rpar Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> Ampersand expr . Equal expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ Rpar Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Comma Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ Rpar Plus_op Or Mult_op Matches Lpar Hash Equal Eq_op Dot Comma Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Ampersand expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Lpar False Wildcard
##
## Ends in an error in state: 326.
##
## call_arg -> expr . [ Rpar Comma ]
## expr_no_ident -> expr . And expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Or expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Lpar False Comma With
##
## Ends in an error in state: 328.
##
## separated_nonempty_list(Comma,call_arg) -> call_arg Comma . separated_nonempty_list(Comma,call_arg) [ Rpar ]
##
## The known suffix of the stack is as follows:
## call_arg Comma
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Ctor Lpar False Comma False Semicolon
##
## Ends in an error in state: 331.
##
## upcases -> Ctor Lpar tuple . Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Ctor Lpar tuple
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 337, spurious reduction of production separated_nonempty_list(Comma,expr) -> expr
## In state 336, spurious reduction of production tuple -> expr Comma separated_nonempty_list(Comma,expr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Ctor Lpar False Wildcard
##
## Ends in an error in state: 333.
##
## expr_no_ident -> expr . And expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Or expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## tuple -> expr . Comma separated_nonempty_list(Comma,expr) [ Rpar ]
## upcases -> Ctor Lpar expr . Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Ctor Lpar expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Comma With
##
## Ends in an error in state: 335.
##
## tuple -> expr Comma . separated_nonempty_list(Comma,expr) [ Semicolon Rpar Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## expr Comma
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Comma False Wildcard
##
## Ends in an error in state: 337.
##
## expr_no_ident -> expr . And expr [ Semicolon Rpar Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Or expr [ Semicolon Rpar Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ Semicolon Rpar Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ Semicolon Rpar Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ Semicolon Rpar Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ Semicolon Rpar Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ Semicolon Rpar Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ Semicolon Rpar Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ Semicolon Rpar Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ Semicolon Rpar Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ Semicolon Rpar Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ Semicolon Rpar Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ Semicolon Rpar Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## separated_nonempty_list(Comma,expr) -> expr . [ Semicolon Rpar Rcurly Eof ]
## separated_nonempty_list(Comma,expr) -> expr . Comma separated_nonempty_list(Comma,expr) [ Semicolon Rpar Rcurly Eof ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ Semicolon Rpar Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ Semicolon Rpar Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Comma False Comma With
##
## Ends in an error in state: 338.
##
## separated_nonempty_list(Comma,expr) -> expr Comma . separated_nonempty_list(Comma,expr) [ Semicolon Rpar Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## expr Comma
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fmt Lpar False Semicolon
##
## Ends in an error in state: 341.
##
## parens(expr) -> Lpar loption(separated_nonempty_list(Comma,expr)) . Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Lpar loption(separated_nonempty_list(Comma,expr))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 337, spurious reduction of production separated_nonempty_list(Comma,expr) -> expr
## In state 340, spurious reduction of production loption(separated_nonempty_list(Comma,expr)) -> separated_nonempty_list(Comma,expr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Ident Colon False Wildcard
##
## Ends in an error in state: 344.
##
## expr_no_ident -> expr . And expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Or expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## lambda -> Fun only_one_param loption(capture_copies) Colon expr . [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Fun only_one_param loption(capture_copies) Colon expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Ident With
##
## Ends in an error in state: 346.
##
## basic_pattern -> ident . [ Lcurly Lbrack Colon ]
## basic_pattern -> ident . Ampersand [ Lcurly Lbrack Colon ]
## basic_pattern -> ident . Exclamation [ Lcurly Lbrack Colon ]
## func_name -> ident . [ Lpar ]
##
## The known suffix of the stack is as follows:
## ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Ident Lpar Rpar With
##
## Ends in an error in state: 348.
##
## func -> func_name parens(param_decl) . loption(capture_copies) option(return_annot) block [ Semicolon Rcurly Eof ]
## func_colon -> func_name parens(param_decl) . loption(capture_copies) option(return_annot) Colon expr [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## func_name parens(param_decl)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Ident Lpar Rpar Lbrack Ident Rbrack With
##
## Ends in an error in state: 349.
##
## func -> func_name parens(param_decl) loption(capture_copies) . option(return_annot) block [ Semicolon Rcurly Eof ]
## func_colon -> func_name parens(param_decl) loption(capture_copies) . option(return_annot) Colon expr [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## func_name parens(param_decl) loption(capture_copies)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Ident Lpar Rpar Colon With
##
## Ends in an error in state: 351.
##
## func_colon -> func_name parens(param_decl) loption(capture_copies) option(return_annot) Colon . expr [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## func_name parens(param_decl) loption(capture_copies) option(return_annot) Colon
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Ident Lpar Rpar Colon False Wildcard
##
## Ends in an error in state: 352.
##
## expr_no_ident -> expr . And expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Or expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Cmp_op And ]
## func_colon -> func_name parens(param_decl) loption(capture_copies) option(return_annot) Colon expr . [ Semicolon Rcurly Eof ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Cmp_op And ]
##
## The known suffix of the stack is as follows:
## func_name parens(param_decl) loption(capture_copies) option(return_annot) Colon expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: If False Lcurly Ident Eof
##
## Ends in an error in state: 358.
##
## separated_nonempty_list(Semicolon,stmt) -> stmt . [ Rcurly ]
## separated_nonempty_list(Semicolon,stmt) -> stmt . Semicolon separated_nonempty_list(Semicolon,stmt) [ Rcurly ]
##
## The known suffix of the stack is as follows:
## stmt
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 361, spurious reduction of production stmt -> ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: If False Lcurly Ident Semicolon With
##
## Ends in an error in state: 359.
##
## separated_nonempty_list(Semicolon,stmt) -> stmt Semicolon . separated_nonempty_list(Semicolon,stmt) [ Rcurly ]
##
## The known suffix of the stack is as follows:
## stmt Semicolon
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Ident With
##
## Ends in an error in state: 361.
##
## expr -> ident . [ Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## stmt -> ident . [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False Wildcard
##
## Ends in an error in state: 362.
##
## expr -> expr_no_ident . [ With Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## stmt_no_ident -> expr_no_ident . [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## expr_no_ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: False With
##
## Ends in an error in state: 363.
##
## expr_no_ident -> expr . And expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Or expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Comma Cmp_op And ]
## tuple -> expr . Comma separated_nonempty_list(Comma,expr) [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 362, spurious reduction of production expr -> expr_no_ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Lpar Rpar Colon With
##
## Ends in an error in state: 366.
##
## lambda -> Fun parens(param_decl) loption(capture_copies) option(return_annot) Colon . expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Fun parens(param_decl) loption(capture_copies) option(return_annot) Colon
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Fun Lpar Rpar Colon False Wildcard
##
## Ends in an error in state: 367.
##
## expr_no_ident -> expr . And expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Or expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## lambda -> Fun parens(param_decl) loption(capture_copies) option(return_annot) Colon expr . [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Fun parens(param_decl) loption(capture_copies) option(return_annot) Colon expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Lbrack False Wildcard
##
## Ends in an error in state: 370.
##
## expr_no_ident -> expr . And expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Or expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## separated_nonempty_trailing_list(Comma,expr,Rbrack) -> expr . option(Comma) Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## separated_nonempty_trailing_list(Comma,expr,Rbrack) -> expr . Comma separated_nonempty_trailing_list(Comma,expr,Rbrack) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Lbrack False Comma With
##
## Ends in an error in state: 371.
##
## option(Comma) -> Comma . [ Rbrack ]
## separated_nonempty_trailing_list(Comma,expr,Rbrack) -> expr Comma . separated_nonempty_trailing_list(Comma,expr,Rbrack) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr Comma
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Hash Int With
##
## Ends in an error in state: 375.
##
## fixed_array_lit -> Hash Int . Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Hash Int
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Hash Int Lbrack With
##
## Ends in an error in state: 376.
##
## fixed_array_lit -> Hash Int Lbrack . expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Hash Int Lbrack
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Hash Int Lbrack False Wildcard
##
## Ends in an error in state: 377.
##
## expr_no_ident -> expr . And expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Or expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## fixed_array_lit -> Hash Int Lbrack expr . Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ Rbrack Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Hash Int Lbrack expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: If False Wildcard
##
## Ends in an error in state: 379.
##
## expr_no_ident -> expr . And expr [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Or expr [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> If expr . block ifcont [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
##
## The known suffix of the stack is as follows:
## If expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: If False Lcurly Ident Rcurly Wildcard
##
## Ends in an error in state: 380.
##
## expr_no_ident -> If expr block . ifcont [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## If expr block
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: If False Lcurly Ident Rcurly Else With
##
## Ends in an error in state: 381.
##
## ifcont -> Else . block [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## ifcont -> Else . If expr block ifcont [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Else
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: If False Lcurly Ident Rcurly Else If With
##
## Ends in an error in state: 382.
##
## ifcont -> Else If . expr block ifcont [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Else If
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: If False Lcurly Ident Rcurly Else If False Wildcard
##
## Ends in an error in state: 383.
##
## expr_no_ident -> expr . And expr [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Or expr [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## ifcont -> Else If expr . block ifcont [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Dot Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Else If expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: If False Lcurly Ident Rcurly Else If False Lcurly Ident Rcurly Wildcard
##
## Ends in an error in state: 384.
##
## ifcont -> Else If expr block . ifcont [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Else If expr block
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Match Exclamation With
##
## Ends in an error in state: 390.
##
## passed(expr) -> Exclamation . expr [ Semicolon Rcurly Lcurly Eof ]
##
## The known suffix of the stack is as follows:
## Exclamation
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Match Exclamation False Wildcard
##
## Ends in an error in state: 391.
##
## expr_no_ident -> expr . And expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Or expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## passed(expr) -> Exclamation expr . [ Semicolon Rcurly Lcurly Eof ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Exclamation expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Let Ident Equal Builtin_id With
##
## Ends in an error in state: 392.
##
## expr_no_ident -> Builtin_id . parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Eof Dot Cmp_op And ]
## stmt_no_ident -> Let let_decl Equal Builtin_id . [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Let let_decl Equal Builtin_id
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Match Ampersand With
##
## Ends in an error in state: 393.
##
## expr_no_ident -> Ampersand . expr Equal expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## passed(expr) -> Ampersand . expr [ Semicolon Rcurly Lcurly Eof ]
##
## The known suffix of the stack is as follows:
## Ampersand
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Match Ampersand False Wildcard
##
## Ends in an error in state: 394.
##
## expr_no_ident -> expr . And expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Or expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> Ampersand expr . Equal expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## passed(expr) -> Ampersand expr . [ Semicolon Rcurly Lcurly Eof ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Ampersand expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Match False Wildcard
##
## Ends in an error in state: 396.
##
## expr_no_ident -> expr . And expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Or expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## passed(expr) -> expr . [ Semicolon Rcurly Lcurly Eof ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Lcurly Hash Eq_op Eof Dot Cmp_op And ]
##
## The known suffix of the stack is as follows:
## expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Lcurly False Eof
##
## Ends in an error in state: 397.
##
## expr_no_ident -> Lcurly stmt_no_ident . block_cont [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Lcurly stmt_no_ident
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 362, spurious reduction of production stmt_no_ident -> expr_no_ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Lcurly False Semicolon With
##
## Ends in an error in state: 398.
##
## block_cont -> Semicolon . separated_nonempty_list(Semicolon,stmt) Rcurly [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Semicolon
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Lcurly Ident Comma With
##
## Ends in an error in state: 405.
##
## option(Comma) -> Comma . [ Rcurly ]
## separated_nonempty_trailing_list(Comma,record_item,Rcurly) -> record_item Comma . separated_nonempty_trailing_list(Comma,record_item,Rcurly) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## record_item Comma
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Lcurly Ident With Ident With
##
## Ends in an error in state: 407.
##
## record_item -> ident . Equal expr [ Rcurly Comma ]
## record_item -> ident . [ Rcurly Comma ]
##
## The known suffix of the stack is as follows:
## ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Lcurly Ident Equal With
##
## Ends in an error in state: 408.
##
## record_item -> ident Equal . expr [ Rcurly Comma ]
##
## The known suffix of the stack is as follows:
## ident Equal
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Lcurly Ident Equal False Wildcard
##
## Ends in an error in state: 409.
##
## expr_no_ident -> expr . And expr [ Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Or expr [ Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## record_item -> ident Equal expr . [ Rcurly Comma ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
##
## The known suffix of the stack is as follows:
## ident Equal expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Lcurly Ident Wildcard
##
## Ends in an error in state: 412.
##
## expr -> ident . [ With Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## record_item -> ident . Equal expr [ Rcurly Comma ]
## record_item -> ident . [ Rcurly Comma ]
##
## The known suffix of the stack is as follows:
## ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Lcurly False Comma
##
## Ends in an error in state: 413.
##
## expr_no_ident -> expr . And expr [ With Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Or expr [ With Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ With Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ With Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ With Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ With Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ With Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ With Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ With Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ With Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ With Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ With Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ With Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> Lcurly expr . With separated_nonempty_trailing_list(Comma,record_item,Rcurly) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ With Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ With Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Lcurly expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 362, spurious reduction of production expr -> expr_no_ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Lcurly Ident With With
##
## Ends in an error in state: 414.
##
## expr_no_ident -> Lcurly expr With . separated_nonempty_trailing_list(Comma,record_item,Rcurly) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Lcurly expr With
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Lpar False Comma False Semicolon
##
## Ends in an error in state: 416.
##
## expr_no_ident -> Lpar tuple . Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Lpar tuple
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 337, spurious reduction of production separated_nonempty_list(Comma,expr) -> expr
## In state 336, spurious reduction of production tuple -> expr Comma separated_nonempty_list(Comma,expr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Lpar False Wildcard
##
## Ends in an error in state: 418.
##
## expr_no_ident -> expr . And expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Or expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## expr_no_ident -> Lpar expr . Rpar [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ Rpar Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Comma Cmp_op And ]
## tuple -> expr . Comma separated_nonempty_list(Comma,expr) [ Rpar ]
##
## The known suffix of the stack is as follows:
## Lpar expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Match False Semicolon
##
## Ends in an error in state: 420.
##
## expr_no_ident -> Match passed(expr) . Lcurly clauses Rcurly [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Match passed(expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 396, spurious reduction of production passed(expr) -> expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Match False Lcurly With
##
## Ends in an error in state: 421.
##
## expr_no_ident -> Match passed(expr) Lcurly . clauses Rcurly [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Match passed(expr) Lcurly
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Match False Lcurly Cmp_op Wildcard
##
## Ends in an error in state: 423.
##
## match_pattern -> pattern . [ Colon And ]
## match_pattern -> pattern . Hbar separated_nonempty_list(Hbar,pattern) [ Colon And ]
##
## The known suffix of the stack is as follows:
## pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Match False Lcurly Ident Hbar With
##
## Ends in an error in state: 424.
##
## match_pattern -> pattern Hbar . separated_nonempty_list(Hbar,pattern) [ Colon And ]
##
## The known suffix of the stack is as follows:
## pattern Hbar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Match False Lcurly Ident Hbar Ident Rpar
##
## Ends in an error in state: 426.
##
## clause -> option(clause_path) match_pattern . option(guard) Colon expr [ Semicolon Rcurly ]
##
## The known suffix of the stack is as follows:
## option(clause_path) match_pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 170, spurious reduction of production basic_pattern -> ident
## In state 173, spurious reduction of production pattern -> basic_pattern
## In state 191, spurious reduction of production separated_nonempty_list(Hbar,pattern) -> pattern
## In state 425, spurious reduction of production match_pattern -> pattern Hbar separated_nonempty_list(Hbar,pattern)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Match False Lcurly Ident And With
##
## Ends in an error in state: 427.
##
## guard -> And . expr [ Colon ]
##
## The known suffix of the stack is as follows:
## And
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Match False Lcurly Ident And False Wildcard
##
## Ends in an error in state: 428.
##
## expr_no_ident -> expr . And expr [ Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Colon Cmp_op And ]
## expr_no_ident -> expr . Or expr [ Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Colon Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Colon Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Colon Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Colon Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Colon Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Colon Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Colon Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Colon Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Colon Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Colon Cmp_op And ]
## guard -> And expr . [ Colon ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Colon Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## And expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Match False Lcurly Ident Colon With
##
## Ends in an error in state: 430.
##
## clause -> option(clause_path) match_pattern option(guard) Colon . expr [ Semicolon Rcurly ]
##
## The known suffix of the stack is as follows:
## option(clause_path) match_pattern option(guard) Colon
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Match False Lcurly Ident Colon False Wildcard
##
## Ends in an error in state: 431.
##
## clause -> option(clause_path) match_pattern option(guard) Colon expr . [ Semicolon Rcurly ]
## expr_no_ident -> expr . And expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Or expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ Semicolon Rcurly Plus_op Or Mult_op Matches Lpar Hash Eq_op Dot Cmp_op And ]
##
## The known suffix of the stack is as follows:
## option(clause_path) match_pattern option(guard) Colon expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Match False Lcurly Ident Colon False Semicolon With
##
## Ends in an error in state: 438.
##
## clauses -> clause Semicolon . clauses [ Rcurly ]
##
## The known suffix of the stack is as follows:
## clause Semicolon
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Plus_op False Wildcard
##
## Ends in an error in state: 441.
##
## expr_no_ident -> expr . And expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Or expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Matches pattern [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Eq_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Cmp_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Plus_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Mult_op expr [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> Plus_op expr . [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot ident parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot path_ident parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Lpar expr Rpar parens(call_arg) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot Fmt parens(expr) [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## expr_no_ident -> expr . Dot ident [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Dot Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
## special_builtins -> expr . Hash Lbrack expr Rbrack [ With Semicolon Rpar Rcurly Rbrack Plus_op Or Mult_op Matches Lpar Lcurly Hash Equal Eq_op Eof Dot Comma Colon Cmp_op And ]
##
## The known suffix of the stack is as follows:
## Plus_op expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Module With
##
## Ends in an error in state: 442.
##
## modtype -> Module . Type ident Lcurly sig_items Rcurly [ Semicolon Rcurly Eof ]
## modul -> Module . module_decl Lcurly separated_nonempty_list(Semicolon,top_item) Rcurly [ Semicolon Rcurly Eof ]
## modul -> Module . module_decl Equal path_with_loc [ Semicolon Rcurly Eof ]
## modul -> Module . module_decl Equal module_application [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Module
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Module Type With
##
## Ends in an error in state: 443.
##
## modtype -> Module Type . ident Lcurly sig_items Rcurly [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Module Type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Module Type Ident With
##
## Ends in an error in state: 444.
##
## modtype -> Module Type ident . Lcurly sig_items Rcurly [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Module Type ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Module Type Ident Lcurly With
##
## Ends in an error in state: 445.
##
## modtype -> Module Type ident Lcurly . sig_items Rcurly [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Module Type ident Lcurly
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Module Ident Lpar
##
## Ends in an error in state: 448.
##
## modul -> Module module_decl . Lcurly separated_nonempty_list(Semicolon,top_item) Rcurly [ Semicolon Rcurly Eof ]
## modul -> Module module_decl . Equal path_with_loc [ Semicolon Rcurly Eof ]
## modul -> Module module_decl . Equal module_application [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Module module_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 483, spurious reduction of production module_decl -> ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Module Ident Lcurly With
##
## Ends in an error in state: 449.
##
## modul -> Module module_decl Lcurly . separated_nonempty_list(Semicolon,top_item) Rcurly [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Module module_decl Lcurly
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Import With
##
## Ends in an error in state: 450.
##
## top_item -> Import . Ident [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Import
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Functor With
##
## Ends in an error in state: 452.
##
## functor_ -> Functor . module_decl Lpar loption(separated_nonempty_list(Comma,functor_param)) Rpar Lcurly separated_nonempty_list(Semicolon,top_item) Rcurly [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Functor
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Functor Ident Lcurly
##
## Ends in an error in state: 453.
##
## functor_ -> Functor module_decl . Lpar loption(separated_nonempty_list(Comma,functor_param)) Rpar Lcurly separated_nonempty_list(Semicolon,top_item) Rcurly [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Functor module_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 483, spurious reduction of production module_decl -> ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Functor Ident Lpar With
##
## Ends in an error in state: 454.
##
## functor_ -> Functor module_decl Lpar . loption(separated_nonempty_list(Comma,functor_param)) Rpar Lcurly separated_nonempty_list(Semicolon,top_item) Rcurly [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Functor module_decl Lpar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Functor Ident Lpar Rpar With
##
## Ends in an error in state: 457.
##
## functor_ -> Functor module_decl Lpar loption(separated_nonempty_list(Comma,functor_param)) Rpar . Lcurly separated_nonempty_list(Semicolon,top_item) Rcurly [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Functor module_decl Lpar loption(separated_nonempty_list(Comma,functor_param)) Rpar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Functor Ident Lpar Rpar Lcurly With
##
## Ends in an error in state: 458.
##
## functor_ -> Functor module_decl Lpar loption(separated_nonempty_list(Comma,functor_param)) Rpar Lcurly . separated_nonempty_list(Semicolon,top_item) Rcurly [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Functor module_decl Lpar loption(separated_nonempty_list(Comma,functor_param)) Rpar Lcurly
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External With
##
## Ends in an error in state: 459.
##
## ext -> External . ident Colon type_spec [ Semicolon Rcurly Eof ]
## ext -> External . ident Colon type_spec Equal String_lit [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## External
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident With
##
## Ends in an error in state: 460.
##
## ext -> External ident . Colon type_spec [ Semicolon Rcurly Eof ]
## ext -> External ident . Colon type_spec Equal String_lit [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## External ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon With
##
## Ends in an error in state: 461.
##
## ext -> External ident Colon . type_spec [ Semicolon Rcurly Eof ]
## ext -> External ident Colon . type_spec Equal String_lit [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## External ident Colon
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Ident Rpar
##
## Ends in an error in state: 462.
##
## ext -> External ident Colon type_spec . [ Semicolon Rcurly Eof ]
## ext -> External ident Colon type_spec . Equal String_lit [ Semicolon Rcurly Eof ]
## type_spec -> type_spec . Lbrack separated_nonempty_list(Comma,type_spec) Rbrack [ Semicolon Rcurly Lbrack Equal Eof ]
##
## The known suffix of the stack is as follows:
## External ident Colon type_spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production ident -> Ident
## In state 39, spurious reduction of production type_spec -> ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: External Ident Colon Ident Equal With
##
## Ends in an error in state: 463.
##
## ext -> External ident Colon type_spec Equal . String_lit [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## External ident Colon type_spec Equal
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Use Ident With
##
## Ends in an error in state: 466.
##
## separated_nonempty_list(Semicolon,top_item) -> top_item . [ Rcurly Eof ]
## separated_nonempty_list(Semicolon,top_item) -> top_item . Semicolon separated_nonempty_list(Semicolon,top_item) [ Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## top_item
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Ident Semicolon With
##
## Ends in an error in state: 467.
##
## separated_nonempty_list(Semicolon,top_item) -> top_item Semicolon . separated_nonempty_list(Semicolon,top_item) [ Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## top_item Semicolon
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Functor Ident Lpar Rpar Lcurly Ident Eof
##
## Ends in an error in state: 475.
##
## functor_ -> Functor module_decl Lpar loption(separated_nonempty_list(Comma,functor_param)) Rpar Lcurly separated_nonempty_list(Semicolon,top_item) . Rcurly [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Functor module_decl Lpar loption(separated_nonempty_list(Comma,functor_param)) Rpar Lcurly separated_nonempty_list(Semicolon,top_item)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 361, spurious reduction of production stmt -> ident
## In state 468, spurious reduction of production top_item -> stmt
## In state 466, spurious reduction of production separated_nonempty_list(Semicolon,top_item) -> top_item
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Functor Ident Lpar Ident With
##
## Ends in an error in state: 477.
##
## functor_param -> ident . Colon use_path [ Rpar Comma ]
##
## The known suffix of the stack is as follows:
## ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Functor Ident Lpar Ident Colon With
##
## Ends in an error in state: 478.
##
## functor_param -> ident Colon . use_path [ Rpar Comma ]
##
## The known suffix of the stack is as follows:
## ident Colon
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Functor Ident Lpar Ident Colon Ident With
##
## Ends in an error in state: 480.
##
## separated_nonempty_list(Comma,functor_param) -> functor_param . [ Rpar ]
## separated_nonempty_list(Comma,functor_param) -> functor_param . Comma separated_nonempty_list(Comma,functor_param) [ Rpar ]
##
## The known suffix of the stack is as follows:
## functor_param
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Functor Ident Lpar Ident Colon Ident Comma With
##
## Ends in an error in state: 481.
##
## separated_nonempty_list(Comma,functor_param) -> functor_param Comma . separated_nonempty_list(Comma,functor_param) [ Rpar ]
##
## The known suffix of the stack is as follows:
## functor_param Comma
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Functor Ident With
##
## Ends in an error in state: 483.
##
## module_decl -> ident . [ Lpar Lcurly Equal ]
## module_decl -> ident . Colon use_path [ Lpar Lcurly Equal ]
##
## The known suffix of the stack is as follows:
## ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Functor Ident Colon With
##
## Ends in an error in state: 484.
##
## module_decl -> ident Colon . use_path [ Lpar Lcurly Equal ]
##
## The known suffix of the stack is as follows:
## ident Colon
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Module Ident Lcurly Ident Eof
##
## Ends in an error in state: 486.
##
## modul -> Module module_decl Lcurly separated_nonempty_list(Semicolon,top_item) . Rcurly [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Module module_decl Lcurly separated_nonempty_list(Semicolon,top_item)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 361, spurious reduction of production stmt -> ident
## In state 468, spurious reduction of production top_item -> stmt
## In state 466, spurious reduction of production separated_nonempty_list(Semicolon,top_item) -> top_item
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Module Ident Equal With
##
## Ends in an error in state: 488.
##
## modul -> Module module_decl Equal . path_with_loc [ Semicolon Rcurly Eof ]
## modul -> Module module_decl Equal . module_application [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Module module_decl Equal
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Module Ident Equal Ident With
##
## Ends in an error in state: 490.
##
## modul -> Module module_decl Equal path_with_loc . [ Semicolon Rcurly Eof ]
## module_application -> path_with_loc . parens(path_with_loc) [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Module module_decl Equal path_with_loc
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Module Ident Equal Ident Lpar With
##
## Ends in an error in state: 491.
##
## parens(path_with_loc) -> Lpar . loption(separated_nonempty_list(Comma,path_with_loc)) Rpar [ Semicolon Rcurly Eof ]
##
## The known suffix of the stack is as follows:
## Lpar
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Module Ident Equal Ident Lpar Ident With
##
## Ends in an error in state: 493.
##
## separated_nonempty_list(Comma,path_with_loc) -> path_with_loc . [ Rpar ]
## separated_nonempty_list(Comma,path_with_loc) -> path_with_loc . Comma separated_nonempty_list(Comma,path_with_loc) [ Rpar ]
##
## The known suffix of the stack is as follows:
## path_with_loc
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Module Ident Equal Ident Lpar Ident Comma With
##
## Ends in an error in state: 494.
##
## separated_nonempty_list(Comma,path_with_loc) -> path_with_loc Comma . separated_nonempty_list(Comma,path_with_loc) [ Rpar ]
##
## The known suffix of the stack is as follows:
## path_with_loc Comma
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: Ident Rcurly
##
## Ends in an error in state: 502.
##
## prog -> loption(separated_nonempty_list(Semicolon,top_item)) . Eof [ # ]
##
## The known suffix of the stack is as follows:
## loption(separated_nonempty_list(Semicolon,top_item))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 361, spurious reduction of production stmt -> ident
## In state 468, spurious reduction of production top_item -> stmt
## In state 466, spurious reduction of production separated_nonempty_list(Semicolon,top_item) -> top_item
## In state 500, spurious reduction of production loption(separated_nonempty_list(Semicolon,top_item)) -> separated_nonempty_list(Semicolon,top_item)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

