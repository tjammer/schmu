type iter_status = Continue | Exhausted

module iter {
  type exhausted = iter_status
  type t['a] = (('a) -> unit) -> exhausted
}

module type iterable {
  type t['a]
  val to_iter : (t['a]) -> iter/t['a]
}


fun range(start, limit, fn) {
 let state& = !start
  fun aux(f) {
    f(state)
    if state == limit - 1 { Exhausted }
    else {
      &state = state + 1
      Continue
    }
  }
  fn(aux)
}

fun fold(it, init!, fn) {
  fun rec inner(accum!) {
    let accum& = !accum
    match it(fun v {
      let acc = fn(!accum, v)
      &accum = acc
    }) {
      Exhausted: accum
      Continue: inner(!accum)
    }
  }
  inner(!init)
}

fun filter(it, predicate, consume) {
  fun rec aux(f) {
    let pass& = true
    match it(fun v: if predicate(v) { f(v) } else { &pass = false }) {
      Exhausted: Exhausted
      Continue: {
        if pass { Continue } -- value was used, not exhausted
        else { aux(f) } -- try again
      }
    }
  }
  consume(aux)
}

fun take(it, num, fn) {
  let curr& = 0
  fun aux(f) {
    match it(f) {
      Exhausted: Exhausted
      Continue: {
        if curr == num - 1 { Exhausted }
        else {
          &curr = curr + 1
          Continue
        }
      }
    }
  }
  fn(aux)
}

fun array_to_iter(arr, cont) {
  let state& = 0
  fun aux(f) {
    if state == array/length(arr) { Exhausted }
    else {
      f(arr.[state])
      &state = state + 1
      Continue
    }
  }
  cont(aux)
}

-- range(0, 10,
array_to_iter([0, 1, 3, 4],
      fun it: {
  filter(it, fun i : i.mod(2) == 0, fun it {
    take(it, 5, fun it {
      take(it, 5, fun it {
        fold(it, !0, fun (acc!, i) {
          println(fmt(i))
          acc + i
        })
      })
    })
  })
}).fmt().println()


-- range(0, 10)
-- | filter(fun i : i.mod(2) == 0)
-- | take(5)
-- | take(5)
-- | fold(0, fun (acc!, i) {
--   println(fmt(i))
--   acc + i
-- })

fun iter(it, fn) {
  fun rec aux() {
    match it(fn) {
      Exhausted: ()
      Continue: aux()
    }
  }
  aux()
}

fun f(acc!, i) {
  println(fmt(i))
  acc + i
}

-- range(0, 10, >filter(fun _: true, >take(5, >take(5, >fold(0, f)))))
-- .fmt().println()
range(0, 10, >filter(fun _: true, >take(5, >take(5, >iter(fun i: println(fmt("in it: ", i)))))))

range(0, 10)
~> filter(fun i : i.mod(2) == 0)
~> take(5)
~> take(5)
~> fold(!0, fun (acc!, i) {
  println(fmt(i))
  acc + i
}).fmt().println()


-- range(0, 10) | > filter(fun _: true, >take(5, >take(5, >iter(fun i: println(fmt("in it: ", i))))))

-- range(0, 10, >filter(fun _: true), >take(5, >take(5, >fold(0, f))))

-- a(b(c(0), 1), 2)
-- c(0).b(1).a(2)

range(0, 10)
~> filter(fun _: true)
~> take(5)
~> fold(0, f)
.fmt().println()
