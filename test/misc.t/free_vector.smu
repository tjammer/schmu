type foo = { x : int }
type container = { index : int, vec : vector(int) }

val x = { x = 1 }

-- These are freed at the end of the program
val vec = ["hey", "young", "world"]
val vec = [x, {x = 2}, {x = 3}]

-- Vec is only alive inside the function and should be freed there
fun vec_inside() =
  val vec = [x, {x = 2}, {x = 3}]
  -- Make sure we can call realloc
   vec.ptr.optr <- __realloc(vec.ptr.optr, 9)

-- Vec is returned and should be freed in its parent scope
fun make_vec() =
  val x = { x = 23 }
  [x, {x = 2}, {x = 3}]

fun inner_parent_scope() =
  ignore(make_vec())

-- Vec can be propagated out through multiple function calls
fun nest_fns() =
  make_vec()

fun make_nested_vec() =
  val nested = [[0, 1], [2, 3]]
  nested

fun nest_allocs() =
  make_nested_vec()

-- Should be freed locally
fun nest_local() =
  ignore([[0, 1], [2, 3]])

-- Records of vectors
fun record_of_vecs() =
  val vec = [1, 2]
  { index = 1, vec = vec }

-- Vectors of records (of vectors)
fun vec_of_records() =
  [record_of_vecs(), record_of_vecs()]

val vec = make_vec()
vec_inside()
inner_parent_scope()
val normal = nest_fns()

val nested = [[0, 1], [2, 3]]
nested.ptr.optr <- __realloc(nested.ptr.optr, 9)
val nested = make_nested_vec()
val nested = nest_allocs()
nest_local()

val rec_of_vec = { index = 12, vec = [1, 2]}
val rec_of_vec = record_of_vecs()

val vec_of_rec = [record_of_vecs(), record_of_vecs()]
val vec_of_rec = vec_of_records()
0
