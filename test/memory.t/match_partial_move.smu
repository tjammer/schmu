module async {
  type prom_state['a] =
    | Pending
    | Queued1(fun ('a) -> unit)
    | Queued_n(array[unit])
    | Resolved(a)

  fun wait() {
    rc/create(Pending)
  }

  fun resolve(p&, v!) {
    let inner& <- rc/mut(&p)
    match inner {
      Queued1(_) -> ()
      Queued_n(cbs) -> {
        let _cbs = !cbs
        &inner = Resolved(v)
      }
      _b -> &inner = Pending
    }
  }

  fun bind(fut, fn!) {
    let cp& = copy(fut)
    let cp& <- rc/mut(&cp)
    match cp {
      Pending ->
      &cp = Queued1(fun a { fn(a) })
      _ -> ()
    }
  }
}

let future& = async/wait()
async/bind(future, fun _v { () })
async/resolve(&future, 3)
