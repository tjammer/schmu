(type lexbuf  {:buf string :curr int})
(type view {:pbuf string :start int :len int})
(type ok {:rem lexbuf :mtch view})
(type parse-result ((#ok ok) (#err lexbuf)))

(defn char [c]
  (fn [buf]
    (if (char-equal buf.buf.[buf.curr] c)
      (#ok {:mtch {:pbuf (copy buf.buf) :start buf.curr :len 1}
            :rem {@(copy buf) :curr (+ 1 buf.curr)}})
      (#err (copy buf)))))

(defn string-of-view [view]
  (let (ret& (array/create (+ 1 view.len)))
    (iter-range (.start view) (+ view.start view.len)
                (fn [c] (array/push &ret !(copy view.pbuf.[c]))))
    (array/push &ret !'\000')
    (array/drop-back &ret)
    ret))

(defn view-of-lexbuf [lb]
  {:pbuf (copy lb.buf) :start lb.curr :len (- (array/length lb.buf) lb.curr)})

(defn print-result [res]
  (-> (match res
        ((#ok {:rem :mtch})
         (fmt-str "(\"" (string-of-view (view-of-lexbuf rem))
                  "\", \"" (string-of-view mtch) "\")"))
        ((#err lexbuf)
         (fmt-str "(\"" (string-of-view (view-of-lexbuf lexbuf)) "\", \"\")")))
      print))

(defn alt [a b]
 (fn [buf] -- This variable is polymorphic
   (match (a buf)
     ((#ok r) (#ok r))
     ((#err _) (b buf)))))

(def lx {:buf "x" :curr 0})
(def li {:buf "ix" :curr 0})
(def l0 {:buf "xi" :curr 0})

(def c (alt (char 'x') (char 'i')))

(print-result (c lx))
(print-result (c li))
(print-result (c l0))
