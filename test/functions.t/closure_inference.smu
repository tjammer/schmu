type lexbuf = {buf : string, curr : int}
type view = {pbuf : string, start : int, len : int}
type ok = {rem : lexbuf, mtch : view}
type parse_result = Ok(ok) | Err(lexbuf)

fun char(c):
  fun buf:
    if char_equal(String.get(buf.buf, buf.curr), c):
      Ok({mtch = {pbuf = copy(buf.buf), start = buf.curr, len = 1},
          rem = {copy(buf) with curr = buf.curr + 1}})
    else:
      Err(copy(buf))

fun string_of_view(view):
  let ret& = Array.create(view.len + 1)
  iter_range(view.start, view.start + view.len, fun c:
    Array.push(&ret, !String.get(view.pbuf, c)))
  Array.push(&ret, !'\000')
  Array.drop_back(&ret)
  ret

fun view_of_lexbuf(lb):
  {pbuf = copy(lb.buf), start = lb.curr, len = String.len(lb.buf) - lb.curr}

fun print_result(res):
  match res:
    Ok({rem, mtch}):
      fmt("(\"", string_of_view(view_of_lexbuf(rem)), "\", \"",
        string_of_view(mtch), "\")")
    Err(lexbuf):
      fmt("\"", string_of_view(view_of_lexbuf(lexbuf)), "\", \"")
  -> print

fun alt(a, b):
  fun (buf) [a, b]: -- [buf] is polymorphic
    match a(buf):
      Ok(r): Ok(r)
      Err(_): b(buf)

let lx = {buf = "x", curr = 0}
let li = {buf = "ix", curr = 0}
let l0 = {buf = "xi", curr = 0}

let c = alt(char('x'), char('i'))

print_result(c(lx))
print_result(c(li))
print_result(c(l0))
