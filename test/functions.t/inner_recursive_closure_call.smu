module type ordered {
  type t
}
functor make(ord : ordered) {
  type key = ord/t
  type t = { v : key, r : option[rc[t]] }
  fun iter(t, cont) {
    fun rec aux(t) {
      match t {
        None -> false 
        Some(rc) -> {
          let i <- rc/read(rc)
          -- ignoring the result makes this closure polymorphic, which adds
          -- another error case we check
          ignore(cont(i.v)) 
          aux(i.r) 
        }
      }
    }
    aux(t)
  }
}
module set = make(int)

let hmm = Some( rc/create(set/{ v = 12, r = None }))

set/iter(hmm) |> iter/iter(fun i { fmt/(println(int, i))})

-- iter/iter(fun a { set/iter(hmm, a) }, fun i { fmt/(println(int, i)) })
