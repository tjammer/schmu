(type bref {:a& bool})

(defn mut-bref [i rf&]
  (if (> i 0)
    (set &(.a rf) true)
    (mut-bref (+ i 1) &rf)))

(defn dontmut-bref [i rf&]
  (if (> i 0)
    (set &(.a rf) false)
    -- introduce a new object, so the old one won't get mutated
    (do
      (def rf2& {:a true})
      (dontmut-bref (+ i 1) &rf2))))

(def rf& {:a false})

(mut-bref 0 &rf)

-- change from false to true
(print (fmt-str (.a rf)))

(dontmut-bref 0 &rf)

-- don't change
(print (fmt-str (.a rf)))

-- same for int record type
(type r {:a& int})

(defn mod-rec [r& i]
  (if (= i 2)
    (set &(.a r) i)
    (mod-rec &r (+ i 1))))

(let [ar& {:a 20}]
  (mod-rec &ar 0)
  (print (fmt-str (.a ar))))

-- array
(defn push-twice [a& i]
  (if (= i 2)
    ()
    (do
      (array-push &a 20)
      (push-twice &a (+ i 1)))))

(let [a& [10 20]]
  (push-twice &a 0)
  (print (fmt-str (array-length a))))

-- int
(defn change-int [i& j]
  (if (= j 100)
    (set &i j)
    (change-int &i (+ j 1))))

(let [i& 0]
  (change-int &i 0)
  (print (fmt-str i)))

-- create bogus objects to tidy up
(defn test [a& i]
  (cond
    ((= i 2) (let [b& [10]]
               (test &b (+ i 1))))
    ((= i 10) (let [b& [10]]
                (test &b (+ i 1))))
    ((= i 12) ())
    (else (do
            (array-push &a 20)
            (test &a (+ i 1))))))

(let [a& []]
  (test &a 0)
  (print (fmt-str (array-length a))))
